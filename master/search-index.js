var N = null;var searchIndex = {};
searchIndex["parquet"]={"doc":"Apache Parquet is a columnar storage format that provides efficient data compression and encoding schemes to improve performance of handling complex nested data structures. Parquet implements record-shredding and assembly algorithm described in the Dremel paper.","items":[[0,"errors","parquet","Common Parquet errors and macros.",N,N],[4,"ParquetError","parquet::errors","Set of errors that can be produced during different operations in Parquet.",N,N],[13,"General","","General Parquet error. Returned when code violates normal workflow of working with Parquet files.",0,N],[13,"NYI","","\"Not yet implemented\" Parquet error. Returned when functionality is not yet available.",0,N],[13,"EOF","","\"End of file\" Parquet error. Returned when IO related failures occur, e.g. when there are not enough bytes to decode.",0,N],[6,"Result","","A specialized `Result` for Parquet errors.",N,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"eq","","",0,[[["self"],["parqueterror"]],["bool"]]],[11,"ne","","",0,[[["self"],["parqueterror"]],["bool"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"description","","",0,[[["self"]],["str"]]],[11,"cause","","",0,[[["self"]],["option",["error"]]]],[11,"from","","",0,[[["error"]],["parqueterror"]]],[11,"from","","",0,[[["error"]],["parqueterror"]]],[11,"from","","",0,[[["error"]],["parqueterror"]]],[11,"from","","",0,[[["borrowmuterror"]],["parqueterror"]]],[0,"basic","parquet","Contains Rust mappings for Thrift definition. Refer to `parquet.thrift` file to see raw definitions.",N,N],[4,"Type","parquet::basic","Types supported by Parquet. These physical types are intended to be used in combination with the encodings to control the on disk storage format. For example INT16 is not included as a type since a good encoding of INT32 would handle this.",N,N],[13,"BOOLEAN","","",1,N],[13,"INT32","","",1,N],[13,"INT64","","",1,N],[13,"INT96","","",1,N],[13,"FLOAT","","",1,N],[13,"DOUBLE","","",1,N],[13,"BYTE_ARRAY","","",1,N],[13,"FIXED_LEN_BYTE_ARRAY","","",1,N],[4,"LogicalType","","Common types (logical types) used by frameworks when using Parquet. This helps map between types in those frameworks to the base types in Parquet. This is only metadata and not needed to read or write the data.",N,N],[13,"NONE","","",2,N],[13,"UTF8","","A BYTE_ARRAY actually contains UTF8 encoded chars.",2,N],[13,"MAP","","A map is converted as an optional field containing a repeated key/value pair.",2,N],[13,"MAP_KEY_VALUE","","A key/value pair is converted into a group of two fields.",2,N],[13,"LIST","","A list is converted into an optional field containing a repeated field for its values.",2,N],[13,"ENUM","","An enum is converted into a binary field",2,N],[13,"DECIMAL","","A decimal value. This may be used to annotate binary or fixed primitive types. The underlying byte array stores the unscaled value encoded as two's complement using big-endian byte order (the most significant byte is the zeroth element).",2,N],[13,"DATE","","A date stored as days since Unix epoch, encoded as the INT32 physical type.",2,N],[13,"TIME_MILLIS","","The total number of milliseconds since midnight. The value is stored as an INT32 physical type.",2,N],[13,"TIME_MICROS","","The total number of microseconds since midnight. The value is stored as an INT64 physical type.",2,N],[13,"TIMESTAMP_MILLIS","","Date and time recorded as milliseconds since the Unix epoch. Recorded as a physical type of INT64.",2,N],[13,"TIMESTAMP_MICROS","","Date and time recorded as microseconds since the Unix epoch. The value is stored as an INT64 physical type.",2,N],[13,"UINT_8","","An unsigned 8 bit integer value stored as INT32 physical type.",2,N],[13,"UINT_16","","An unsigned 16 bit integer value stored as INT32 physical type.",2,N],[13,"UINT_32","","An unsigned 32 bit integer value stored as INT32 physical type.",2,N],[13,"UINT_64","","An unsigned 64 bit integer value stored as INT64 physical type.",2,N],[13,"INT_8","","A signed 8 bit integer value stored as INT32 physical type.",2,N],[13,"INT_16","","A signed 16 bit integer value stored as INT32 physical type.",2,N],[13,"INT_32","","A signed 32 bit integer value stored as INT32 physical type.",2,N],[13,"INT_64","","A signed 64 bit integer value stored as INT64 physical type.",2,N],[13,"JSON","","A JSON document embedded within a single UTF8 column.",2,N],[13,"BSON","","A BSON document embedded within a single BINARY column.",2,N],[13,"INTERVAL","","An interval of time.",2,N],[4,"Repetition","","Representation of field types in schema.",N,N],[13,"REQUIRED","","Field is required (can not be null) and each record has exactly 1 value.",3,N],[13,"OPTIONAL","","Field is optional (can be null) and each record has 0 or 1 values.",3,N],[13,"REPEATED","","Field is repeated and can contain 0 or more values.",3,N],[4,"Encoding","","Encodings supported by Parquet. Not all encodings are valid for all types. These enums are also used to specify the encoding of definition and repetition levels.",N,N],[13,"PLAIN","","Default byte encoding. - BOOLEAN - 1 bit per value, 0 is false; 1 is true. - INT32 - 4 bytes per value, stored as little-endian. - INT64 - 8 bytes per value, stored as little-endian. - FLOAT - 4 bytes per value, stored as little-endian. - DOUBLE - 8 bytes per value, stored as little-endian. - BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes. - FIXED_LEN_BYTE_ARRAY - just the bytes are stored.",4,N],[13,"PLAIN_DICTIONARY","","Deprecated dictionary encoding.",4,N],[13,"RLE","","Group packed run length encoding.",4,N],[13,"BIT_PACKED","","Bit packed encoding.",4,N],[13,"DELTA_BINARY_PACKED","","Delta encoding for integers, either INT32 or INT64.",4,N],[13,"DELTA_LENGTH_BYTE_ARRAY","","Encoding for byte arrays to separate the length values and the data.",4,N],[13,"DELTA_BYTE_ARRAY","","Incremental encoding for byte arrays.",4,N],[13,"RLE_DICTIONARY","","Dictionary encoding.",4,N],[4,"Compression","","Supported compression algorithms.",N,N],[13,"UNCOMPRESSED","","",5,N],[13,"SNAPPY","","",5,N],[13,"GZIP","","",5,N],[13,"LZO","","",5,N],[13,"BROTLI","","",5,N],[13,"LZ4","","",5,N],[13,"ZSTD","","",5,N],[4,"PageType","","Available data pages for Parquet file format. Note that some of the page types may not be supported.",N,N],[13,"DATA_PAGE","","",6,N],[13,"INDEX_PAGE","","",6,N],[13,"DICTIONARY_PAGE","","",6,N],[13,"DATA_PAGE_V2","","",6,N],[4,"SortOrder","","Sort order for page and column statistics.",N,N],[13,"SIGNED","","Signed (either value or legacy byte-wise) comparison.",7,N],[13,"UNSIGNED","","Unsigned (depending on physical type either value or byte-wise) comparison.",7,N],[13,"UNDEFINED","","Comparison is undefined.",7,N],[4,"ColumnOrder","","Column order that specifies what method was used to aggregate min/max values for statistics.",N,N],[13,"TYPE_DEFINED_ORDER","","Column uses the order defined by its logical or physical type (if there is no logical type), parquet-format 2.4.0+.",8,N],[13,"UNDEFINED","","Undefined column order, means legacy behaviour before parquet-format 2.4.0. Sort order is always SIGNED.",8,N],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"clone","","",1,[[["self"]],["type"]]],[11,"eq","","",1,[[["self"],["type"]],["bool"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"clone","","",2,[[["self"]],["logicaltype"]]],[11,"eq","","",2,[[["self"],["logicaltype"]],["bool"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"clone","","",3,[[["self"]],["repetition"]]],[11,"eq","","",3,[[["self"],["repetition"]],["bool"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"clone","","",4,[[["self"]],["encoding"]]],[11,"eq","","",4,[[["self"],["encoding"]],["bool"]]],[11,"hash","","",4,N],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"clone","","",5,[[["self"]],["compression"]]],[11,"eq","","",5,[[["self"],["compression"]],["bool"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"clone","","",6,[[["self"]],["pagetype"]]],[11,"eq","","",6,[[["self"],["pagetype"]],["bool"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"clone","","",7,[[["self"]],["sortorder"]]],[11,"eq","","",7,[[["self"],["sortorder"]],["bool"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"clone","","",8,[[["self"]],["columnorder"]]],[11,"eq","","",8,[[["self"],["columnorder"]],["bool"]]],[11,"ne","","",8,[[["self"],["columnorder"]],["bool"]]],[11,"get_sort_order","","Returns sort order for a physical/logical type.",8,[[["logicaltype"],["type"]],["sortorder"]]],[11,"sort_order","","Returns sort order associated with this column order.",8,[[["self"]],["sortorder"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"from","","",1,[[["type"]],["self"]]],[11,"from","","",2,[[["option",["convertedtype"]]],["self"]]],[11,"from","","",3,[[["fieldrepetitiontype"]],["self"]]],[11,"from","","",4,[[["encoding"]],["self"]]],[11,"from","","",5,[[["compressioncodec"]],["self"]]],[11,"from","","",6,[[["pagetype"]],["self"]]],[11,"from_str","","",3,[[["str"]],["result"]]],[11,"from_str","","",1,[[["str"]],["result"]]],[11,"from_str","","",2,[[["str"]],["result"]]],[0,"data_type","parquet","Data types that connect Parquet physical types with their Rust-specific representations.",N,N],[3,"Int96","parquet::data_type","Rust representation for logical type INT96, value is backed by an array of `u32`. The type only takes 12 bytes, without extra padding.",N,N],[3,"ByteArray","","Rust representation for BYTE_ARRAY and FIXED_LEN_BYTE_ARRAY Parquet physical types. Value is backed by a byte buffer.",N,N],[3,"BoolType","","",N,N],[3,"Int32Type","","",N,N],[3,"Int64Type","","",N,N],[3,"Int96Type","","",N,N],[3,"FloatType","","",N,N],[3,"DoubleType","","",N,N],[3,"ByteArrayType","","",N,N],[3,"FixedLenByteArrayType","","",N,N],[4,"Decimal","","Rust representation for Decimal values.",N,N],[13,"Int32","","Decimal backed by `i32`.",9,N],[12,"value","parquet::data_type::Decimal","",9,N],[12,"precision","","",9,N],[12,"scale","","",9,N],[13,"Int64","parquet::data_type","Decimal backed by `i64`.",9,N],[12,"value","parquet::data_type::Decimal","",9,N],[12,"precision","","",9,N],[12,"scale","","",9,N],[13,"Bytes","parquet::data_type","Decimal backed by byte array.",9,N],[12,"value","parquet::data_type::Decimal","",9,N],[12,"precision","","",9,N],[12,"scale","","",9,N],[8,"AsBytes","parquet::data_type","Converts an instance of data type to a slice of bytes as `u8`.",N,N],[10,"as_bytes","","Returns slice of bytes for this data type.",10,N],[8,"DataType","","Contains the Parquet physical type information as well as the Rust primitive type presentation.",N,N],[16,"T","","",11,N],[10,"get_physical_type","","Returns Parquet physical type.",11,[[],["type"]]],[10,"get_type_size","","Returns size in bytes for Rust representation of the physical type.",11,[[],["usize"]]],[11,"clone","","",12,[[["self"]],["int96"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates new INT96 type struct with no data set.",12,[[],["self"]]],[11,"data","","Returns underlying data as slice of [`u32`].",12,N],[11,"set_data","","Sets data for this INT96 type.",12,[[["self"],["u32"],["u32"],["u32"]]]],[11,"default","","",12,[[],["self"]]],[11,"eq","","",12,[[["self"],["int96"]],["bool"]]],[11,"from","","",12,[[["vec",["u32"]]],["self"]]],[11,"clone","","",13,[[["self"]],["bytearray"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates new byte array with no data set.",13,[[],["self"]]],[11,"len","","Gets length of the underlying byte buffer.",13,[[["self"]],["usize"]]],[11,"data","","Returns slice of data.",13,N],[11,"set_data","","Set data from another byte buffer.",13,[[["self"],["bytebufferptr"]]]],[11,"slice","","Returns `ByteArray` instance with slice of values for a data.",13,[[["self"],["usize"],["usize"]],["self"]]],[11,"from","","",13,[[["vec",["u8"]]],["bytearray"]]],[11,"from","","",13,[[["str"]],["bytearray"]]],[11,"from","","",13,[[["bytebufferptr"]],["bytearray"]]],[11,"from","","",13,[[["bytebuffer"]],["bytearray"]]],[11,"default","","",13,[[],["self"]]],[11,"eq","","",13,[[["self"],["bytearray"]],["bool"]]],[11,"clone","","",9,[[["self"]],["decimal"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"from_i32","","Creates new decimal value from `i32`.",9,[[["i32"],["i32"],["i32"]],["self"]]],[11,"from_i64","","Creates new decimal value from `i64`.",9,[[["i64"],["i32"],["i32"]],["self"]]],[11,"from_bytes","","Creates new decimal value from `ByteArray`.",9,[[["bytearray"],["i32"],["i32"]],["self"]]],[11,"data","","Returns bytes of unscaled value.",9,N],[11,"precision","","Returns decimal precision.",9,[[["self"]],["i32"]]],[11,"scale","","Returns decimal scale.",9,[[["self"]],["i32"]]],[11,"default","","",9,[[],["self"]]],[11,"eq","","",9,[[["self"],["decimal"]],["bool"]]],[11,"as_bytes","","",12,N],[11,"as_bytes","","",13,N],[11,"as_bytes","","",9,N],[11,"get_physical_type","","",14,[[],["type"]]],[11,"get_type_size","","",14,[[],["usize"]]],[11,"get_physical_type","","",15,[[],["type"]]],[11,"get_type_size","","",15,[[],["usize"]]],[11,"get_physical_type","","",16,[[],["type"]]],[11,"get_type_size","","",16,[[],["usize"]]],[11,"get_physical_type","","",17,[[],["type"]]],[11,"get_type_size","","",17,[[],["usize"]]],[11,"get_physical_type","","",18,[[],["type"]]],[11,"get_type_size","","",18,[[],["usize"]]],[11,"get_physical_type","","",19,[[],["type"]]],[11,"get_type_size","","",19,[[],["usize"]]],[11,"get_physical_type","","",20,[[],["type"]]],[11,"get_type_size","","",20,[[],["usize"]]],[11,"get_physical_type","","",21,[[],["type"]]],[11,"get_type_size","","",21,[[],["usize"]]],[0,"memory","parquet","Utility methods and structs for working with memory.",N,N],[3,"MemTracker","parquet::memory","Struct to track memory usage information.",N,N],[3,"Buffer","","A resize-able buffer class with generic member, with optional memory tracker.",N,N],[3,"BufferPtr","","An representation of a slice on a reference-counting and read-only byte array. Sub-slices can be further created from this. The byte array will be released when all slices are dropped.",N,N],[6,"MemTrackerPtr","","Reference counted pointer for [`MemTracker`].",N,N],[6,"WeakMemTrackerPtr","","Non-owning reference for [`MemTracker`].",N,N],[6,"ByteBuffer","","Type alias for [`Buffer`].",N,N],[6,"ByteBufferPtr","","Type alias for [`BufferPtr`].",N,N],[0,"encoding","parquet","Contains all supported encoders for Parquet.",N,N],[3,"PlainEncoder","parquet::encoding","Plain encoding that supports all types. Values are encoded back to back. The plain encoding is used whenever a more efficient encoding can not be used. It stores the data in the following format: - BOOLEAN - 1 bit per value, 0 is false; 1 is true. - INT32 - 4 bytes per value, stored as little-endian. - INT64 - 8 bytes per value, stored as little-endian. - FLOAT - 4 bytes per value, stored as IEEE little-endian. - DOUBLE - 8 bytes per value, stored as IEEE little-endian. - BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes. - FIXED_LEN_BYTE_ARRAY - just the bytes are stored.",N,N],[3,"DictEncoder","","Dictionary encoder. The dictionary encoding builds a dictionary of values encountered in a given column. The dictionary page is written first, before the data pages of the column chunk.",N,N],[3,"RleValueEncoder","","RLE/Bit-Packing hybrid encoding for values. Currently is used only for data pages v2 and supports boolean types.",N,N],[3,"DeltaBitPackEncoder","","Delta bit packed encoder. Consists of a header followed by blocks of delta encoded values binary packed.",N,N],[3,"DeltaLengthByteArrayEncoder","","Encoding for byte arrays to separate the length values and the data. The lengths are encoded using DELTA_BINARY_PACKED encoding, data is stored as raw bytes.",N,N],[3,"DeltaByteArrayEncoder","","Encoding for byte arrays, prefix lengths are encoded using DELTA_BINARY_PACKED encoding, followed by suffixes with DELTA_LENGTH_BYTE_ARRAY encoding.",N,N],[5,"get_encoder","","Gets a encoder for the particular data type `T` and encoding `encoding`. Memory usage for the encoder instance is tracked by `mem_tracker`.",N,[[["columndescptr"],["encoding"],["memtrackerptr"]],["result",["box"]]]],[8,"Encoder","","An Parquet encoder for the data type `T`.",N,N],[10,"put","","Encodes data from `values`.",22,N],[10,"encoding","","Returns the encoding type of this encoder.",22,[[["self"]],["encoding"]]],[10,"estimated_data_encoded_size","","Returns an estimate of the encoded data, in bytes. Method call must be O(1).",22,[[["self"]],["usize"]]],[10,"flush_buffer","","Flushes the underlying byte buffer that's being processed by this encoder, and return the immutable copy of it. This will also reset the internal state.",22,[[["self"]],["result",["bytebufferptr"]]]],[0,"decoding","parquet","Contains all supported decoders for Parquet.",N,N],[3,"PlainDecoder","parquet::decoding","Plain decoding that supports all types. Values are encoded back to back. For native types, data is encoded as little endian. Floating point types are encoded in IEEE. See `PlainDecoder` for more information.",N,N],[3,"DictDecoder","","Dictionary decoder. The dictionary encoding builds a dictionary of values encountered in a given column. The dictionary is be stored in a dictionary page per column chunk. See `DictEncoder` for more information.",N,N],[3,"RleValueDecoder","","RLE/Bit-Packing hybrid decoding for values. Currently is used only for data pages v2 and supports boolean types. See `RleValueEncoder` for more information.",N,N],[3,"DeltaBitPackDecoder","","Delta binary packed decoder. Supports INT32 and INT64 types. See `DeltaBitPackEncoder` for more information.",N,N],[3,"DeltaLengthByteArrayDecoder","","Delta length byte array decoder. Only applied to byte arrays to separate the length values and the data, the lengths are encoded using DELTA_BINARY_PACKED encoding. See `DeltaLengthByteArrayEncoder` for more information.",N,N],[3,"DeltaByteArrayDecoder","","Delta byte array decoder. Prefix lengths are encoded using `DELTA_BINARY_PACKED` encoding, Suffixes are stored using `DELTA_LENGTH_BYTE_ARRAY` encoding. See `DeltaByteArrayEncoder` for more information.",N,N],[5,"get_decoder","","Gets a decoder for the column descriptor `descr` and encoding type `encoding`.",N,[[["columndescptr"],["encoding"]],["result",["box"]]]],[8,"Decoder","","A Parquet decoder for the data type `T`.",N,N],[10,"set_data","","Sets the data to decode to be `data`, which should contain `num_values` of values to decode.",23,[[["self"],["bytebufferptr"],["usize"]],["result"]]],[10,"get","","Consumes values from this decoder and write the results to `buffer`. This will try to fill up `buffer`.",23,N],[10,"values_left","","Returns the number of values left in this decoder stream.",23,[[["self"]],["usize"]]],[10,"encoding","","Returns the encoding for this decoder.",23,[[["self"]],["encoding"]]],[11,"fmt","parquet::memory","",24,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates new memory tracker.",24,[[],["memtracker"]]],[11,"memory_usage","","Returns the current memory consumption, in bytes.",24,[[["self"]],["i64"]]],[11,"max_memory_usage","","Returns the maximum memory consumption so far, in bytes.",24,[[["self"]],["i64"]]],[11,"alloc","","Adds `num_bytes` to the memory consumption tracked by this memory tracker.",24,[[["self"],["i64"]]]],[11,"new","","Creates new empty buffer.",25,[[],["self"]]],[11,"with_mem_tracker","","Adds [`MemTracker`] for this buffer.",25,[[["self"],["memtrackerptr"]],["self"]]],[11,"data","","Returns slice of data in this buffer.",25,N],[11,"set_data","","Sets data for this buffer.",25,[[["self"],["vec"]]]],[11,"resize","","Resizes underlying data in place to a new length `new_size`.",25,[[["self"],["usize"],["t"]]]],[11,"clear","","Clears underlying data.",25,[[["self"]]]],[11,"reserve","","Reserves capacity `additional_capacity` for underlying data vector.",25,[[["self"],["usize"]]]],[11,"consume","","Returns [`BufferPtr`] with buffer data. Buffer data is reset.",25,[[["self"]],["bufferptr"]]],[11,"push","","Adds `value` to the buffer.",25,[[["self"],["t"]]]],[11,"capacity","","Returns current capacity for the buffer.",25,[[["self"]],["usize"]]],[11,"size","","Returns current size for the buffer.",25,[[["self"]],["usize"]]],[11,"is_mem_tracked","","Returns `true` if memory tracker is added to buffer, `false` otherwise.",25,[[["self"]],["bool"]]],[11,"mem_tracker","","Returns memory tracker associated with this buffer. This may panic, if memory tracker is not set, use method above to check if memory tracker is available.",25,[[["self"]],["memtrackerptr"]]],[11,"index","","",25,[[["self"],["usize"]],["t"]]],[11,"index_mut","","",25,[[["self"],["usize"]],["t"]]],[11,"write","","",25,N],[11,"flush","","",25,[[["self"]],["ioresult"]]],[11,"as_ref","","",25,N],[11,"drop","","",25,[[["self"]]]],[11,"clone","","",26,[[["self"]],["bufferptr"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates new buffer from a vector.",26,[[["vec"]],["self"]]],[11,"data","","Returns slice of data in this buffer.",26,N],[11,"with_range","","Updates this buffer with new `start` position and length `len`.",26,[[["self"],["usize"],["usize"]],["self"]]],[11,"with_mem_tracker","","Adds memory tracker to this buffer.",26,[[["self"],["memtrackerptr"]],["self"]]],[11,"start","","Returns start position of this buffer.",26,[[["self"]],["usize"]]],[11,"len","","Returns length of this buffer",26,[[["self"]],["usize"]]],[11,"is_mem_tracked","","Returns `true` if this buffer has memory tracker, `false` otherwise.",26,[[["self"]],["bool"]]],[11,"all","","Returns a shallow copy of the buffer. Reference counted pointer to the data is copied.",26,[[["self"]],["bufferptr"]]],[11,"start_from","","Returns a shallow copy of the buffer that starts with `start` position.",26,[[["self"],["usize"]],["bufferptr"]]],[11,"range","","Returns a shallow copy that is a range slice within this buffer.",26,[[["self"],["usize"],["usize"]],["bufferptr"]]],[11,"index","","",26,[[["self"],["usize"]],["t"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["fmtresult"]]],[11,"drop","","",26,[[["self"]]]],[11,"as_ref","","",26,N],[11,"new","parquet::encoding","Creates new plain encoder.",27,[[["columndescptr"],["memtrackerptr"],["vec",["u8"]]],["self"]]],[11,"put","","",27,N],[11,"encoding","","",27,[[["self"]],["encoding"]]],[11,"estimated_data_encoded_size","","",27,[[["self"]],["usize"]]],[11,"flush_buffer","","",27,[[["self"]],["result",["bytebufferptr"]]]],[11,"put","","",27,N],[11,"put","","",27,N],[11,"put","","",27,N],[11,"put","","",27,N],[11,"new","","Creates new dictionary encoder.",28,[[["columndescptr"],["memtrackerptr"]],["self"]]],[11,"is_sorted","","Returns true if dictionary entries are sorted, false otherwise.",28,[[["self"]],["bool"]]],[11,"num_entries","","Returns number of unique values (keys) in the dictionary.",28,[[["self"]],["usize"]]],[11,"dict_encoded_size","","Returns size of unique values (keys) in the dictionary, in bytes.",28,[[["self"]],["usize"]]],[11,"write_dict","","Writes out the dictionary values with PLAIN encoding in a byte buffer, and return the result.",28,[[["self"]],["result",["bytebufferptr"]]]],[11,"write_indices","","Writes out the dictionary values with RLE encoding in a byte buffer, and return the result.",28,[[["self"]],["result",["bytebufferptr"]]]],[11,"put","","",28,N],[11,"encoding","","",28,[[["self"]],["encoding"]]],[11,"estimated_data_encoded_size","","",28,[[["self"]],["usize"]]],[11,"flush_buffer","","",28,[[["self"]],["result",["bytebufferptr"]]]],[11,"new","","Creates new rle value encoder.",29,[[],["self"]]],[11,"put","","",29,N],[11,"encoding","","",29,[[["self"]],["encoding"]]],[11,"estimated_data_encoded_size","","",29,[[["self"]],["usize"]]],[11,"flush_buffer","","",29,[[["self"]],["result",["bytebufferptr"]]]],[11,"put","","",29,N],[11,"flush_buffer","","",29,[[["self"]],["result",["bytebufferptr"]]]],[11,"new","","Creates new delta bit packed encoder.",30,[[],["self"]]],[11,"put","","",30,N],[11,"encoding","","",30,[[["self"]],["encoding"]]],[11,"estimated_data_encoded_size","","",30,[[["self"]],["usize"]]],[11,"flush_buffer","","",30,[[["self"]],["result",["bytebufferptr"]]]],[11,"new","","Creates new delta length byte array encoder.",31,[[],["self"]]],[11,"put","","",31,N],[11,"encoding","","",31,[[["self"]],["encoding"]]],[11,"estimated_data_encoded_size","","",31,[[["self"]],["usize"]]],[11,"flush_buffer","","",31,[[["self"]],["result",["bytebufferptr"]]]],[11,"put","","",31,N],[11,"flush_buffer","","",31,[[["self"]],["result",["bytebufferptr"]]]],[11,"new","","Creates new delta byte array encoder.",32,[[],["self"]]],[11,"put","","",32,N],[11,"encoding","","",32,[[["self"]],["encoding"]]],[11,"estimated_data_encoded_size","","",32,[[["self"]],["usize"]]],[11,"flush_buffer","","",32,[[["self"]],["result",["bytebufferptr"]]]],[11,"put","","",32,N],[11,"flush_buffer","","",32,[[["self"]],["result",["bytebufferptr"]]]],[11,"put","","",32,N],[11,"flush_buffer","","",32,[[["self"]],["result",["bytebufferptr"]]]],[11,"new","parquet::decoding","Creates new plain decoder.",33,[[["i32"]],["self"]]],[11,"set_data","","",33,[[["self"],["bytebufferptr"],["usize"]],["result"]]],[11,"values_left","","",33,[[["self"]],["usize"]]],[11,"encoding","","",33,[[["self"]],["encoding"]]],[11,"get","","",33,N],[11,"get","","",33,N],[11,"set_data","","",33,[[["self"],["bytebufferptr"],["usize"]],["result"]]],[11,"get","","",33,N],[11,"get","","",33,N],[11,"get","","",33,N],[11,"new","","Creates new dictionary decoder.",34,[[],["self"]]],[11,"set_dict","","Decodes and sets values for dictionary using `decoder` decoder.",34,[[["self"],["box",["decoder"]]],["result"]]],[11,"set_data","","",34,[[["self"],["bytebufferptr"],["usize"]],["result"]]],[11,"get","","",34,N],[11,"values_left","","Number of values left in this decoder stream",34,[[["self"]],["usize"]]],[11,"encoding","","",34,[[["self"]],["encoding"]]],[11,"new","","",35,[[],["self"]]],[11,"set_data","","",35,[[["self"],["bytebufferptr"],["usize"]],["result"]]],[11,"values_left","","",35,[[["self"]],["usize"]]],[11,"encoding","","",35,[[["self"]],["encoding"]]],[11,"get","","",35,N],[11,"set_data","","",35,[[["self"],["bytebufferptr"],["usize"]],["result"]]],[11,"new","","Creates new delta bit packed decoder.",36,[[],["self"]]],[11,"get_offset","","Returns underlying bit reader offset.",36,[[["self"]],["usize"]]],[11,"set_data","","",36,[[["self"],["bytebufferptr"],["usize"]],["result"]]],[11,"get","","",36,N],[11,"values_left","","",36,[[["self"]],["usize"]]],[11,"encoding","","",36,[[["self"]],["encoding"]]],[11,"new","","Creates new delta length byte array decoder.",37,[[],["self"]]],[11,"set_data","","",37,[[["self"],["bytebufferptr"],["usize"]],["result"]]],[11,"get","","",37,N],[11,"values_left","","",37,[[["self"]],["usize"]]],[11,"encoding","","",37,[[["self"]],["encoding"]]],[11,"set_data","","",37,[[["self"],["bytebufferptr"],["usize"]],["result"]]],[11,"get","","",37,N],[11,"new","","Creates new delta byte array decoder.",38,[[],["self"]]],[11,"set_data","","",38,[[["self"],["bytebufferptr"],["usize"]],["result"]]],[11,"get","","",38,N],[11,"values_left","","",38,[[["self"]],["usize"]]],[11,"encoding","","",38,[[["self"]],["encoding"]]],[11,"set_data","","",38,[[["self"],["bytebufferptr"],["usize"]],["result"]]],[11,"get","","",38,N],[11,"set_data","","",38,[[["self"],["bytebufferptr"],["usize"]],["result"]]],[11,"get","","",38,N],[0,"compression","parquet","Contains codec interface and supported codec implementations.",N,N],[3,"SnappyCodec","parquet::compression","Codec for Snappy compression format.",N,N],[3,"GZipCodec","","Codec for GZIP compression algorithm.",N,N],[3,"BrotliCodec","","Codec for Brotli compression algorithm.",N,N],[3,"LZ4Codec","","Codec for LZ4 compression algorithm.",N,N],[3,"ZSTDCodec","","Codec for Zstandard compression algorithm.",N,N],[5,"create_codec","","Given the compression type `codec`, returns a codec used to compress and decompress bytes for the compression type. This returns `None` if the codec type is `UNCOMPRESSED`.",N,[[["codectype"]],["result",["option"]]]],[8,"Codec","","Parquet compression codec interface.",N,N],[10,"compress","","Compresses data stored in slice `input_buf` and writes the compressed result to `output_buf`. Note that you'll need to call `clear()` before reusing the same `output_buf` across different `compress` calls.",39,N],[10,"decompress","","Decompresses data stored in slice `input_buf` and writes output to `output_buf`. Returns the total number of bytes written.",39,N],[11,"decompress","","",40,N],[11,"compress","","",40,N],[11,"decompress","","",41,N],[11,"compress","","",41,N],[11,"decompress","","",42,N],[11,"compress","","",42,N],[11,"decompress","","",43,N],[11,"compress","","",43,N],[11,"decompress","","",44,N],[11,"compress","","",44,N],[0,"column","parquet","Low level column reader API.",N,N],[0,"page","parquet::column","Contains Parquet Page definitions and page reader interface.",N,N],[3,"CompressedPage","parquet::column::page","Helper struct to represent pages with potentially compressed buffer (data page v1) or compressed and concatenated buffer (def levels + rep levels + compressed values for data page v2).",N,N],[3,"PageWriteSpec","","Contains page write metrics.",N,N],[12,"page_type","","",45,N],[12,"uncompressed_size","","",45,N],[12,"compressed_size","","",45,N],[12,"num_values","","",45,N],[12,"offset","","",45,N],[12,"bytes_written","","",45,N],[4,"Page","","Parquet Page definition.",N,N],[13,"DataPage","","",46,N],[12,"buf","parquet::column::page::Page","",46,N],[12,"num_values","","",46,N],[12,"encoding","","",46,N],[12,"def_level_encoding","","",46,N],[12,"rep_level_encoding","","",46,N],[12,"statistics","","",46,N],[13,"DataPageV2","parquet::column::page","",46,N],[12,"buf","parquet::column::page::Page","",46,N],[12,"num_values","","",46,N],[12,"encoding","","",46,N],[12,"num_nulls","","",46,N],[12,"num_rows","","",46,N],[12,"def_levels_byte_len","","",46,N],[12,"rep_levels_byte_len","","",46,N],[12,"is_compressed","","",46,N],[12,"statistics","","",46,N],[13,"DictionaryPage","parquet::column::page","",46,N],[12,"buf","parquet::column::page::Page","",46,N],[12,"num_values","","",46,N],[12,"encoding","","",46,N],[12,"is_sorted","","",46,N],[8,"PageReader","parquet::column::page","API for reading pages from a column chunk. This offers a iterator like API to get the next page.",N,N],[10,"get_next_page","","Gets the next page in the column chunk associated with this reader. Returns `None` if there are no pages left.",47,[[["self"]],["result",["option"]]]],[8,"PageWriter","","API for writing pages in a column chunk.",N,N],[10,"write_page","","Writes a page into the output stream/sink. Returns `PageWriteSpec` that contains information about written page metrics, including number of bytes, size, number of values, offset, etc.",48,[[["self"],["compressedpage"]],["result",["pagewritespec"]]]],[10,"write_metadata","","Writes column chunk metadata into the output stream/sink.",48,[[["self"],["columnchunkmetadata"]],["result"]]],[10,"close","","Closes resources and flushes underlying sink. Page writer should not be used after this method is called.",48,[[["self"]],["result"]]],[11,"page_type","","Returns `PageType` for this page.",46,[[["self"]],["pagetype"]]],[11,"buffer","","Returns internal byte buffer reference for this page.",46,[[["self"]],["bytebufferptr"]]],[11,"num_values","","Returns number of values in this page.",46,[[["self"]],["u32"]]],[11,"encoding","","Returns this page `Encoding`.",46,[[["self"]],["encoding"]]],[11,"statistics","","Returns optional `Statistics`.",46,[[["self"]],["option",["statistics"]]]],[11,"new","","Creates `CompressedPage` from a page with potentially compressed buffer and uncompressed size.",49,[[["page"],["usize"]],["self"]]],[11,"page_type","","Returns page type.",49,[[["self"]],["pagetype"]]],[11,"compressed_page","","Returns underlying page with potentially compressed buffer.",49,[[["self"]],["page"]]],[11,"uncompressed_size","","Returns uncompressed size in bytes.",49,[[["self"]],["usize"]]],[11,"compressed_size","","Returns compressed size in bytes.",49,[[["self"]],["usize"]]],[11,"num_values","","Number of values in page.",49,[[["self"]],["u32"]]],[11,"encoding","","Returns encoding for values in page.",49,[[["self"]],["encoding"]]],[11,"data","","Returns slice of compressed buffer in the page.",49,N],[11,"new","","Creates new spec with default page write metrics.",45,[[],["self"]]],[0,"reader","parquet::column","Contains column reader API.",N,N],[3,"ColumnReaderImpl","parquet::column::reader","Typed value reader for a particular primitive column.",N,N],[4,"ColumnReader","","Column reader for a Parquet type.",N,N],[13,"BoolColumnReader","","",50,N],[13,"Int32ColumnReader","","",50,N],[13,"Int64ColumnReader","","",50,N],[13,"Int96ColumnReader","","",50,N],[13,"FloatColumnReader","","",50,N],[13,"DoubleColumnReader","","",50,N],[13,"ByteArrayColumnReader","","",50,N],[13,"FixedLenByteArrayColumnReader","","",50,N],[5,"get_column_reader","","Gets a specific column reader corresponding to column descriptor `col_descr`. The column reader will read from pages in `col_page_reader`.",N,[[["columndescptr"],["box",["pagereader"]]],["columnreader"]]],[5,"get_typed_column_reader","","Gets a typed column reader for the specific type `T`, by \"up-casting\" `col_reader` of non-generic type to a generic column reader type `ColumnReaderImpl`.",N,[[["columnreader"]],["columnreaderimpl"]]],[11,"new","","Creates new column reader based on column descriptor and page reader.",51,[[["columndescptr"],["box",["pagereader"]]],["self"]]],[11,"read_batch","","Reads a batch of values of at most `batch_size`.",51,N],[0,"writer","parquet::column","Contains column writer API.",N,N],[3,"ColumnWriterImpl","parquet::column::writer","Typed column writer for a primitive column.",N,N],[4,"ColumnWriter","","Column writer for a Parquet type.",N,N],[13,"BoolColumnWriter","","",52,N],[13,"Int32ColumnWriter","","",52,N],[13,"Int64ColumnWriter","","",52,N],[13,"Int96ColumnWriter","","",52,N],[13,"FloatColumnWriter","","",52,N],[13,"DoubleColumnWriter","","",52,N],[13,"ByteArrayColumnWriter","","",52,N],[13,"FixedLenByteArrayColumnWriter","","",52,N],[5,"get_column_writer","","Gets a specific column writer corresponding to column descriptor `descr`.",N,[[["columndescptr"],["writerpropertiesptr"],["box",["pagewriter"]]],["columnwriter"]]],[5,"get_typed_column_writer","","Gets a typed column writer for the specific type `T`, by \"up-casting\" `col_writer` of non-generic type to a generic column writer type `ColumnWriterImpl`.",N,[[["columnwriter"]],["columnwriterimpl"]]],[11,"new","","",53,[[["columndescptr"],["writerpropertiesptr"],["box",["pagewriter"]]],["self"]]],[11,"write_batch","","Writes batch of values, definition levels and repetition levels. Returns number of values processed (written).",53,N],[11,"get_total_bytes_written","","Returns total number of bytes written by this column writer so far. This value is also returned when column writer is closed.",53,[[["self"]],["u64"]]],[11,"get_total_rows_written","","Returns total number of rows written by this column writer so far. This value is also returned when column writer is closed.",53,[[["self"]],["u64"]]],[11,"close","","Finalises writes and closes the column writer. Returns total bytes written, total rows written and column chunk metadata.",53,[[["self"]],["result"]]],[0,"record","parquet","Contains record-based API for reading Parquet files.",N,N],[3,"Row","parquet::record","`Row` represents a nested Parquet record.",N,N],[3,"List","","`List` represents a list which contains an array of elements.",N,N],[3,"Map","","`Map` represents a map which contains an list of key->value pairs.",N,N],[0,"reader","","Contains implementation of record assembly and converting Parquet types into `Row`s.",N,N],[3,"TreeBuilder","parquet::record::reader","Tree builder for `Reader` enum. Serves as a container of options for building a reader tree and a builder, and accessing a records iterator [`RowIter`].",N,N],[3,"RowIter","","Iterator of `Row`s. It is used either for a single row group to iterate over data in that row group, or an entire file with auto buffering of all row groups.",N,N],[3,"ReaderIter","","Internal iterator of `Row`s for a reader.",N,N],[4,"Reader","","Reader tree for record assembly",N,N],[13,"PrimitiveReader","","",54,N],[13,"OptionReader","","",54,N],[13,"GroupReader","","",54,N],[13,"RepeatedReader","","",54,N],[13,"KeyValueReader","","",54,N],[11,"new","","Creates new tree builder with default parameters.",55,[[],["self"]]],[11,"with_batch_size","","Sets batch size for this tree builder.",55,[[["self"],["usize"]],["self"]]],[11,"build","","Creates new root reader for provided schema and row group.",55,[[["self"],["schemadescptr"],["rowgroupreader"]],["reader"]]],[11,"as_iter","","Creates iterator of `Row`s directly from schema descriptor and row group.",55,[[["self"],["schemadescptr"],["rowgroupreader"]],["readeriter"]]],[11,"fmt","","",54,[[["self"],["formatter"]],["result"]]],[11,"from_file","","Creates iterator of `Row`s for all row groups in a file.",56,[[["option",["type"]],["filereader"]],["result"]]],[11,"from_row_group","","Creates iterator of `Row`s for a specific row group.",56,[[["option",["type"]],["rowgroupreader"]],["result"]]],[11,"next","","",56,[[["self"]],["option",["row"]]]],[11,"next","","",57,[[["self"]],["option",["row"]]]],[11,"clone","parquet::record","",58,[[["self"]],["row"]]],[11,"fmt","","",58,[[["self"],["formatter"]],["result"]]],[11,"eq","","",58,[[["self"],["row"]],["bool"]]],[11,"ne","","",58,[[["self"],["row"]],["bool"]]],[11,"len","","Get the number of fields in this row.",58,[[["self"]],["usize"]]],[11,"get_bool","","",58,[[["self"],["usize"]],["result",["bool"]]]],[11,"get_byte","","",58,[[["self"],["usize"]],["result",["i8"]]]],[11,"get_short","","",58,[[["self"],["usize"]],["result",["i16"]]]],[11,"get_int","","",58,[[["self"],["usize"]],["result",["i32"]]]],[11,"get_long","","",58,[[["self"],["usize"]],["result",["i64"]]]],[11,"get_float","","",58,[[["self"],["usize"]],["result",["f32"]]]],[11,"get_double","","",58,[[["self"],["usize"]],["result",["f64"]]]],[11,"get_timestamp","","",58,[[["self"],["usize"]],["result",["u64"]]]],[11,"get_decimal","","",58,[[["self"],["usize"]],["result",["decimal"]]]],[11,"get_string","","",58,[[["self"],["usize"]],["result",["string"]]]],[11,"get_bytes","","",58,[[["self"],["usize"]],["result",["bytearray"]]]],[11,"get_group","","",58,[[["self"],["usize"]],["result",["row"]]]],[11,"get_list","","",58,[[["self"],["usize"]],["result",["list"]]]],[11,"get_map","","",58,[[["self"],["usize"]],["result",["map"]]]],[11,"fmt","","",58,[[["self"],["formatter"]],["result"]]],[11,"clone","","",59,[[["self"]],["list"]]],[11,"fmt","","",59,[[["self"],["formatter"]],["result"]]],[11,"eq","","",59,[[["self"],["list"]],["bool"]]],[11,"ne","","",59,[[["self"],["list"]],["bool"]]],[11,"len","","Get the number of fields in this row",59,[[["self"]],["usize"]]],[11,"get_bool","","",59,[[["self"],["usize"]],["result",["bool"]]]],[11,"get_byte","","",59,[[["self"],["usize"]],["result",["i8"]]]],[11,"get_short","","",59,[[["self"],["usize"]],["result",["i16"]]]],[11,"get_int","","",59,[[["self"],["usize"]],["result",["i32"]]]],[11,"get_long","","",59,[[["self"],["usize"]],["result",["i64"]]]],[11,"get_float","","",59,[[["self"],["usize"]],["result",["f32"]]]],[11,"get_double","","",59,[[["self"],["usize"]],["result",["f64"]]]],[11,"get_timestamp","","",59,[[["self"],["usize"]],["result",["u64"]]]],[11,"get_decimal","","",59,[[["self"],["usize"]],["result",["decimal"]]]],[11,"get_string","","",59,[[["self"],["usize"]],["result",["string"]]]],[11,"get_bytes","","",59,[[["self"],["usize"]],["result",["bytearray"]]]],[11,"get_group","","",59,[[["self"],["usize"]],["result",["row"]]]],[11,"get_list","","",59,[[["self"],["usize"]],["result",["list"]]]],[11,"get_map","","",59,[[["self"],["usize"]],["result",["map"]]]],[11,"clone","","",60,[[["self"]],["map"]]],[11,"fmt","","",60,[[["self"],["formatter"]],["result"]]],[11,"eq","","",60,[[["self"],["map"]],["bool"]]],[11,"ne","","",60,[[["self"],["map"]],["bool"]]],[11,"len","","Get the number of fields in this row",60,[[["self"]],["usize"]]],[11,"get_keys","","",60,[[["self"]],["box",["listaccessor"]]]],[11,"get_values","","",60,[[["self"]],["box",["listaccessor"]]]],[8,"RowAccessor","","Trait for type-safe convenient access to fields within a Row.",N,N],[10,"get_bool","","",61,[[["self"],["usize"]],["result",["bool"]]]],[10,"get_byte","","",61,[[["self"],["usize"]],["result",["i8"]]]],[10,"get_short","","",61,[[["self"],["usize"]],["result",["i16"]]]],[10,"get_int","","",61,[[["self"],["usize"]],["result",["i32"]]]],[10,"get_long","","",61,[[["self"],["usize"]],["result",["i64"]]]],[10,"get_float","","",61,[[["self"],["usize"]],["result",["f32"]]]],[10,"get_double","","",61,[[["self"],["usize"]],["result",["f64"]]]],[10,"get_timestamp","","",61,[[["self"],["usize"]],["result",["u64"]]]],[10,"get_decimal","","",61,[[["self"],["usize"]],["result",["decimal"]]]],[10,"get_string","","",61,[[["self"],["usize"]],["result",["string"]]]],[10,"get_bytes","","",61,[[["self"],["usize"]],["result",["bytearray"]]]],[10,"get_group","","",61,[[["self"],["usize"]],["result",["row"]]]],[10,"get_list","","",61,[[["self"],["usize"]],["result",["list"]]]],[10,"get_map","","",61,[[["self"],["usize"]],["result",["map"]]]],[8,"ListAccessor","","Trait for type-safe access of an index for a `List`. Note that the get_XXX methods do not do bound checking.",N,N],[10,"get_bool","","",62,[[["self"],["usize"]],["result",["bool"]]]],[10,"get_byte","","",62,[[["self"],["usize"]],["result",["i8"]]]],[10,"get_short","","",62,[[["self"],["usize"]],["result",["i16"]]]],[10,"get_int","","",62,[[["self"],["usize"]],["result",["i32"]]]],[10,"get_long","","",62,[[["self"],["usize"]],["result",["i64"]]]],[10,"get_float","","",62,[[["self"],["usize"]],["result",["f32"]]]],[10,"get_double","","",62,[[["self"],["usize"]],["result",["f64"]]]],[10,"get_timestamp","","",62,[[["self"],["usize"]],["result",["u64"]]]],[10,"get_decimal","","",62,[[["self"],["usize"]],["result",["decimal"]]]],[10,"get_string","","",62,[[["self"],["usize"]],["result",["string"]]]],[10,"get_bytes","","",62,[[["self"],["usize"]],["result",["bytearray"]]]],[10,"get_group","","",62,[[["self"],["usize"]],["result",["row"]]]],[10,"get_list","","",62,[[["self"],["usize"]],["result",["list"]]]],[10,"get_map","","",62,[[["self"],["usize"]],["result",["map"]]]],[8,"MapAccessor","","Trait for type-safe access of an index for a `Map`",N,N],[10,"get_keys","","",63,[[["self"]],["box",["listaccessor"]]]],[10,"get_values","","",63,[[["self"]],["box",["listaccessor"]]]],[0,"schema","parquet","Parquet schema definitions and methods to print and parse schema.",N,N],[0,"types","parquet::schema","Contains structs and methods to build Parquet schema and schema descriptors.",N,N],[3,"PrimitiveTypeBuilder","parquet::schema::types","A builder for primitive types. All attributes are optional except the name and physical type. Note that if not specified explicitly, `Repetition::OPTIONAL` is used.",N,N],[3,"GroupTypeBuilder","","A builder for group types. All attributes are optional except the name. Note that if not specified explicitly, `None` is used as the repetition of the group, which means it is a root (message) type.",N,N],[3,"BasicTypeInfo","","Basic type info. This contains information such as the name of the type, the repetition level, the logical type and the kind of the type (group, primitive).",N,N],[3,"ColumnPath","","Represents a path in a nested schema",N,N],[3,"ColumnDescriptor","","A descriptor for leaf-level primitive columns. This encapsulates information such as definition and repetition levels and is used to re-assemble nested data.",N,N],[3,"SchemaDescriptor","","A schema descriptor. This encapsulates the top-level schemas for all the columns, as well as all descriptors for all the primitive columns.",N,N],[4,"Type","","Representation of a Parquet type. Used to describe primitive leaf fields and structs, including top-level schema. Note that the top-level schema type is represented using `GroupType` whose repetition is `None`.",N,N],[13,"PrimitiveType","","",64,N],[12,"basic_info","parquet::schema::types::Type","",64,N],[12,"physical_type","","",64,N],[12,"type_length","","",64,N],[12,"scale","","",64,N],[12,"precision","","",64,N],[13,"GroupType","parquet::schema::types","",64,N],[12,"basic_info","parquet::schema::types::Type","",64,N],[12,"fields","","",64,N],[5,"from_thrift","parquet::schema::types","Method to convert from Thrift.",N,N],[5,"to_thrift","","Method to convert to Thrift.",N,[[["type"]],["result",["vec"]]]],[6,"TypePtr","","Type alias for `Rc<Type>`.",N,N],[6,"SchemaDescPtr","","Type alias for `Rc<SchemaDescriptor>`.",N,N],[6,"ColumnDescPtr","","Type alias for `Rc<ColumnDescriptor>`.",N,N],[11,"fmt","","",64,[[["self"],["formatter"]],["result"]]],[11,"eq","","",64,[[["self"],["type"]],["bool"]]],[11,"ne","","",64,[[["self"],["type"]],["bool"]]],[11,"primitive_type_builder","","Creates primitive type builder with provided field name and physical type.",64,[[["str"],["physicaltype"]],["primitivetypebuilder"]]],[11,"group_type_builder","","Creates group type builder with provided column name.",64,[[["str"]],["grouptypebuilder"]]],[11,"get_basic_info","","Returns [`BasicTypeInfo`] information about the type.",64,[[["self"]],["basictypeinfo"]]],[11,"name","","Returns this type's field name.",64,[[["self"]],["str"]]],[11,"get_fields","","Gets the fields from this group type. Note that this will panic if called on a non-group type.",64,N],[11,"get_physical_type","","Gets physical type of this primitive type. Note that this will panic if called on a non-primitive type.",64,[[["self"]],["physicaltype"]]],[11,"check_contains","","Checks if `sub_type` schema is part of current schema. This method can be used to check if projected columns are part of the root schema.",64,[[["self"],["type"]],["bool"]]],[11,"is_primitive","","Returns `true` if this type is a primitive type, `false` otherwise.",64,[[["self"]],["bool"]]],[11,"is_group","","Returns `true` if this type is a group type, `false` otherwise.",64,[[["self"]],["bool"]]],[11,"is_schema","","Returns `true` if this type is the top-level schema type (message type).",64,[[["self"]],["bool"]]],[11,"new","","Creates new primitive type builder with provided field name and physical type.",65,[[["str"],["physicaltype"]],["self"]]],[11,"with_repetition","","Sets `Repetition` for this field and returns itself.",65,[[["self"],["repetition"]],["self"]]],[11,"with_logical_type","","Sets `LogicalType` for this field and returns itself.",65,[[["self"],["logicaltype"]],["self"]]],[11,"with_length","","Sets type length and returns itself. This is only applied to FIXED_LEN_BYTE_ARRAY and INT96 (INTERVAL) types, because they maintain fixed size underlying byte array. By default, value is `0`.",65,[[["self"],["i32"]],["self"]]],[11,"with_precision","","Sets precision for Parquet DECIMAL physical type and returns itself. By default, it equals to `0` and used only for decimal context.",65,[[["self"],["i32"]],["self"]]],[11,"with_scale","","Sets scale for Parquet DECIMAL physical type and returns itself. By default, it equals to `0` and used only for decimal context.",65,[[["self"],["i32"]],["self"]]],[11,"with_id","","Sets optional field id and returns itself.",65,[[["self"],["i32"]],["self"]]],[11,"build","","Creates a new `PrimitiveType` instance from the collected attributes. Returns `Err` in case of any building conditions are not met.",65,[[["self"]],["result",["type"]]]],[11,"new","","Creates new group type builder with provided field name.",66,[[["str"]],["self"]]],[11,"with_repetition","","Sets `Repetition` for this field and returns itself.",66,[[["self"],["repetition"]],["self"]]],[11,"with_logical_type","","Sets `LogicalType` for this field and returns itself.",66,[[["self"],["logicaltype"]],["self"]]],[11,"with_fields","","Sets a list of fields that should be child nodes of this field. Returns updated self.",66,[[["self"],["vec"]],["self"]]],[11,"with_id","","Sets optional field id and returns itself.",66,[[["self"],["i32"]],["self"]]],[11,"build","","Creates a new `GroupType` instance from the gathered attributes.",66,[[["self"]],["result",["type"]]]],[11,"fmt","","",67,[[["self"],["formatter"]],["result"]]],[11,"eq","","",67,[[["self"],["basictypeinfo"]],["bool"]]],[11,"ne","","",67,[[["self"],["basictypeinfo"]],["bool"]]],[11,"name","","Returns field name.",67,[[["self"]],["str"]]],[11,"has_repetition","","Returns `true` if type has repetition field set, `false` otherwise. This is mostly applied to group type, because primitive type always has repetition set.",67,[[["self"]],["bool"]]],[11,"repetition","","Returns `Repetition` value for the type.",67,[[["self"]],["repetition"]]],[11,"logical_type","","Returns `LogicalType` value for the type.",67,[[["self"]],["logicaltype"]]],[11,"has_id","","Returns `true` if id is set, `false` otherwise.",67,[[["self"]],["bool"]]],[11,"id","","Returns id value for the type.",67,[[["self"]],["i32"]]],[11,"clone","","",68,[[["self"]],["columnpath"]]],[11,"eq","","",68,[[["self"],["columnpath"]],["bool"]]],[11,"ne","","",68,[[["self"],["columnpath"]],["bool"]]],[11,"fmt","","",68,[[["self"],["formatter"]],["result"]]],[11,"hash","","",68,N],[11,"new","","Creates new column path from vector of field names.",68,[[["vec",["string"]]],["self"]]],[11,"string","","Returns string representation of this column path. ```rust use parquet::schema::types::ColumnPath;",68,[[["self"]],["string"]]],[11,"fmt","","",68,[[["self"],["formatter"]],["result"]]],[11,"from","","",68,[[["vec",["string"]]],["self"]]],[11,"from","","",68,[[["str"]],["self"]]],[11,"from","","",68,[[["string"]],["self"]]],[11,"as_ref","","",68,N],[11,"new","","Creates new descriptor for leaf-level column.",69,[[["typeptr"],["option",["typeptr"]],["i16"],["i16"],["columnpath"]],["self"]]],[11,"max_def_level","","Returns maximum definition level for this column.",69,[[["self"]],["i16"]]],[11,"max_rep_level","","Returns maximum repetition level for this column.",69,[[["self"]],["i16"]]],[11,"path","","Returns [`ColumnPath`] for this column.",69,[[["self"]],["columnpath"]]],[11,"root_type","","Returns root `Type` (most top-level parent field) for this leaf column.",69,[[["self"]],["type"]]],[11,"name","","Returns column name.",69,[[["self"]],["str"]]],[11,"logical_type","","Returns `LogicalType` for this column.",69,[[["self"]],["logicaltype"]]],[11,"physical_type","","Returns physical type for this column. Note that it will panic if called on a non-primitive type.",69,[[["self"]],["physicaltype"]]],[11,"type_length","","Returns type length for this column. Note that it will panic if called on a non-primitive type.",69,[[["self"]],["i32"]]],[11,"type_precision","","Returns type precision for this column. Note that it will panic if called on a non-primitive type.",69,[[["self"]],["i32"]]],[11,"type_scale","","Returns type scale for this column. Note that it will panic if called on a non-primitive type.",69,[[["self"]],["i32"]]],[11,"new","","Creates new schema descriptor from Parquet schema.",70,[[["typeptr"]],["self"]]],[11,"column","","Returns [`ColumnDescriptor`] for a field position.",70,[[["self"],["usize"]],["columndescptr"]]],[11,"columns","","Returns slice of [`ColumnDescriptor`].",70,N],[11,"num_columns","","Returns number of leaf-level columns.",70,[[["self"]],["usize"]]],[11,"get_column_root","","Returns column root `Type` for a field position.",70,[[["self"],["usize"]],["type"]]],[11,"root_schema","","Returns schema as `Type`.",70,[[["self"]],["type"]]],[11,"name","","Returns schema name.",70,[[["self"]],["str"]]],[0,"printer","parquet::schema","Parquet schema printer. Provides methods to print Parquet file schema and list file metadata.",N,N],[5,"print_parquet_metadata","parquet::schema::printer","Prints Parquet metadata `ParquetMetaData` information.",N,[[["write"],["parquetmetadata"]]]],[5,"print_file_metadata","","Prints file metadata `FileMetaData` information.",N,[[["write"],["filemetadata"]]]],[5,"print_schema","","Prints Parquet `Type` information.",N,[[["write"],["type"]]]],[0,"parser","parquet::schema","Parquet schema parser. Provides methods to parse and validate string message type into Parquet `Type`.",N,N],[5,"parse_message_type","parquet::schema::parser","Parses message type as string into a Parquet `Type` which, for example, could be used to extract individual columns. Returns Parquet general error when parsing or validation fails.",N,[[["str"]],["result",["type"]]]],[0,"file","parquet","Main entrypoint for working with Parquet API. Provides access to file and row group readers, record API, etc.",N,N],[0,"metadata","parquet::file","Contains information about available Parquet metadata.",N,N],[3,"ParquetMetaData","parquet::file::metadata","Global Parquet metadata.",N,N],[3,"FileMetaData","","Metadata for a Parquet file.",N,N],[3,"RowGroupMetaData","","Metadata for a row group.",N,N],[3,"RowGroupMetaDataBuilder","","Builder for row group metadata.",N,N],[3,"ColumnChunkMetaData","","Metadata for a column chunk.",N,N],[3,"ColumnChunkMetaDataBuilder","","Builder for column chunk metadata.",N,N],[6,"ParquetMetaDataPtr","","Reference counted pointer for [`ParquetMetaData`].",N,N],[6,"FileMetaDataPtr","","Reference counted pointer for [`FileMetaData`].",N,N],[6,"RowGroupMetaDataPtr","","Reference counted pointer for [`RowGroupMetaData`].",N,N],[6,"ColumnChunkMetaDataPtr","","Reference counted pointer for [`ColumnChunkMetaData`].",N,N],[11,"new","","Creates Parquet metadata from file metadata and a list of row group metadata `Rc`s for each available row group.",71,[[["filemetadata"],["vec",["rowgroupmetadataptr"]]],["self"]]],[11,"file_metadata","","Returns file metadata as reference counted clone.",71,[[["self"]],["filemetadataptr"]]],[11,"num_row_groups","","Returns number of row groups in this file.",71,[[["self"]],["usize"]]],[11,"row_group","","Returns row group metadata for `i`th position. Position should be less than number of row groups `num_row_groups`.",71,[[["self"],["usize"]],["rowgroupmetadataptr"]]],[11,"row_groups","","Returns slice of row group reference counted pointers in this file.",71,N],[11,"new","","Creates new file metadata.",72,[[["i32"],["i64"],["option",["string"]],["typeptr"],["schemadescptr"],["option",["vec"]]],["self"]]],[11,"version","","Returns version of this file.",72,[[["self"]],["i32"]]],[11,"num_rows","","Returns number of rows in the file.",72,[[["self"]],["i64"]]],[11,"created_by","","String message for application that wrote this file.",72,[[["self"]],["option"]]],[11,"schema","","Returns Parquet ['Type`] that describes schema in this file.",72,[[["self"]],["schematype"]]],[11,"schema_descr","","Returns a reference to schema descriptor.",72,[[["self"]],["schemadescriptor"]]],[11,"schema_descr_ptr","","Returns reference counted clone for schema descriptor.",72,[[["self"]],["schemadescptr"]]],[11,"column_orders","","Column (sort) order used for `min` and `max` values of each column in this file.",72,[[["self"]],["option",["vec"]]]],[11,"column_order","","Returns column order for `i`th column in this file. If column orders are not available, returns undefined (legacy) column order.",72,[[["self"],["usize"]],["columnorder"]]],[11,"builder","","Returns builer for row group metadata.",73,[[["schemadescptr"]],["rowgroupmetadatabuilder"]]],[11,"num_columns","","Number of columns in this row group.",73,[[["self"]],["usize"]]],[11,"column","","Returns column chunk metadata for `i`th column.",73,[[["self"],["usize"]],["columnchunkmetadata"]]],[11,"columns","","Returns slice of column chunk metadata [`Rc`] pointers.",73,N],[11,"num_rows","","Number of rows in this row group.",73,[[["self"]],["i64"]]],[11,"total_byte_size","","Total byte size of all uncompressed column data in this row group.",73,[[["self"]],["i64"]]],[11,"schema_descr","","Returns reference to a schema descriptor.",73,[[["self"]],["schemadescriptor"]]],[11,"schema_descr_ptr","","Returns reference counted clone of schema descriptor.",73,[[["self"]],["schemadescptr"]]],[11,"from_thrift","","Method to convert from Thrift.",73,[[["schemadescptr"],["rowgroup"]],["result",["rowgroupmetadata"]]]],[11,"to_thrift","","Method to convert to Thrift.",73,[[["self"]],["rowgroup"]]],[11,"set_num_rows","","Sets number of rows in this row group.",74,[[["self"],["i64"]],["self"]]],[11,"set_total_byte_size","","Sets total size in bytes for this row group.",74,[[["self"],["i64"]],["self"]]],[11,"set_column_metadata","","Sets column metadata for this row group.",74,[[["self"],["vec",["columnchunkmetadataptr"]]],["self"]]],[11,"build","","Builds row group metadata.",74,[[["self"]],["result",["rowgroupmetadata"]]]],[11,"builder","","Returns builder for column chunk metadata.",75,[[["columndescptr"]],["columnchunkmetadatabuilder"]]],[11,"file_path","","File where the column chunk is stored.",75,[[["self"]],["option",["string"]]]],[11,"file_offset","","Byte offset in `file_path()`.",75,[[["self"]],["i64"]]],[11,"column_type","","Type of this column. Must be primitive.",75,[[["self"]],["type"]]],[11,"column_path","","Path (or identifier) of this column.",75,[[["self"]],["columnpath"]]],[11,"column_descr","","Descriptor for this column.",75,[[["self"]],["columndescriptor"]]],[11,"column_descr_ptr","","Reference counted clone of descriptor for this column.",75,[[["self"]],["columndescptr"]]],[11,"encodings","","All encodings used for this column.",75,[[["self"]],["vec"]]],[11,"num_values","","Total number of values in this column chunk.",75,[[["self"]],["i64"]]],[11,"compression","","Compression for this column.",75,[[["self"]],["compression"]]],[11,"compressed_size","","Returns the total compressed data size of this column chunk.",75,[[["self"]],["i64"]]],[11,"uncompressed_size","","Returns the total uncompressed data size of this column chunk.",75,[[["self"]],["i64"]]],[11,"data_page_offset","","Returns the offset for the column data.",75,[[["self"]],["i64"]]],[11,"has_index_page","","Returns `true` if this column chunk contains a index page, `false` otherwise.",75,[[["self"]],["bool"]]],[11,"index_page_offset","","Returns the offset for the index page.",75,[[["self"]],["option",["i64"]]]],[11,"has_dictionary_page","","Returns `true` if this column chunk contains a dictionary page, `false` otherwise.",75,[[["self"]],["bool"]]],[11,"dictionary_page_offset","","Returns the offset for the dictionary page, if any.",75,[[["self"]],["option",["i64"]]]],[11,"statistics","","Returns statistics that are set for this column chunk, or `None` if no statistics are available.",75,[[["self"]],["option",["statistics"]]]],[11,"from_thrift","","Method to convert from Thrift.",75,[[["columndescptr"],["columnchunk"]],["result"]]],[11,"to_thrift","","Method to convert to Thrift.",75,[[["self"]],["columnchunk"]]],[11,"set_encodings","","Sets list of encodings for this column chunk.",76,[[["self"],["vec",["encoding"]]],["self"]]],[11,"set_file_path","","Sets optional file path for this column chunk.",76,[[["self"],["string"]],["self"]]],[11,"set_file_offset","","Sets file offset in bytes.",76,[[["self"],["i64"]],["self"]]],[11,"set_num_values","","Sets number of values.",76,[[["self"],["i64"]],["self"]]],[11,"set_compression","","Sets compression.",76,[[["self"],["compression"]],["self"]]],[11,"set_total_compressed_size","","Sets total compressed size in bytes.",76,[[["self"],["i64"]],["self"]]],[11,"set_total_uncompressed_size","","Sets total uncompressed size in bytes.",76,[[["self"],["i64"]],["self"]]],[11,"set_data_page_offset","","Sets data page offset in bytes.",76,[[["self"],["i64"]],["self"]]],[11,"set_dictionary_page_offset","","Sets optional dictionary page ofset in bytes.",76,[[["self"],["option",["i64"]]],["self"]]],[11,"set_index_page_offset","","Sets optional index page offset in bytes.",76,[[["self"],["option",["i64"]]],["self"]]],[11,"set_statistics","","Sets statistics for this column chunk.",76,[[["self"],["statistics"]],["self"]]],[11,"build","","Builds column chunk metadata.",76,[[["self"]],["result",["columnchunkmetadata"]]]],[0,"properties","parquet::file","Reader and writer properties.",N,N],[3,"WriterProperties","parquet::file::properties","Writer properties.",N,N],[3,"WriterPropertiesBuilder","","Writer properties builder.",N,N],[4,"WriterVersion","","Parquet writer version.",N,N],[13,"PARQUET_1_0","","",77,N],[13,"PARQUET_2_0","","",77,N],[6,"WriterPropertiesPtr","","Reference counted writer properties.",N,N],[11,"fmt","","",77,[[["self"],["formatter"]],["result"]]],[11,"clone","","",77,[[["self"]],["writerversion"]]],[11,"eq","","",77,[[["self"],["writerversion"]],["bool"]]],[11,"as_num","","Returns writer version as `i32`.",77,[[["self"]],["i32"]]],[11,"fmt","","",78,[[["self"],["formatter"]],["result"]]],[11,"clone","","",78,[[["self"]],["writerproperties"]]],[11,"builder","","Returns builder for writer properties with default values.",78,[[],["writerpropertiesbuilder"]]],[11,"data_pagesize_limit","","Returns data page size limit.",78,[[["self"]],["usize"]]],[11,"dictionary_pagesize_limit","","Returns dictionary page size limit.",78,[[["self"]],["usize"]]],[11,"write_batch_size","","Returns configured batch size for writes.",78,[[["self"]],["usize"]]],[11,"max_row_group_size","","Returns max size for a row group.",78,[[["self"]],["usize"]]],[11,"writer_version","","Returns configured writer version.",78,[[["self"]],["writerversion"]]],[11,"created_by","","Returns `created_by` string.",78,[[["self"]],["str"]]],[11,"dictionary_data_page_encoding","","Returns encoding for a data page, when dictionary encoding is enabled. This is not configurable.",78,[[["self"]],["encoding"]]],[11,"dictionary_page_encoding","","Returns encoding for dictionary page, when dictionary encoding is enabled. This is not configurable.",78,[[["self"]],["encoding"]]],[11,"encoding","","Returns encoding for a column. In case when dictionary is enabled, returns fallback encoding.",78,[[["self"],["columnpath"]],["encoding"]]],[11,"compression","","Returns compression codec for a column.",78,[[["self"],["columnpath"]],["compression"]]],[11,"dictionary_enabled","","Returns `true` if dictionary encoding is enabled for a column.",78,[[["self"],["columnpath"]],["bool"]]],[11,"statistics_enabled","","Returns `true` if statistics are enabled for a column.",78,[[["self"],["columnpath"]],["bool"]]],[11,"max_statistics_size","","Returns max size for statistics. Only applicable if statistics are enabled.",78,[[["self"],["columnpath"]],["usize"]]],[11,"build","","Finalizes the configuration and returns immutable writer properties struct.",79,[[["self"]],["writerproperties"]]],[11,"set_writer_version","","Sets writer version.",79,[[["self"],["writerversion"]],["self"]]],[11,"set_data_pagesize_limit","","Sets data page size limit.",79,[[["self"],["usize"]],["self"]]],[11,"set_dictionary_pagesize_limit","","Sets dictionary page size limit.",79,[[["self"],["usize"]],["self"]]],[11,"set_write_batch_size","","Sets write batch size.",79,[[["self"],["usize"]],["self"]]],[11,"set_max_row_group_size","","Sets max size for a row group.",79,[[["self"],["usize"]],["self"]]],[11,"set_created_by","","Sets \"created by\" property.",79,[[["self"],["string"]],["self"]]],[11,"set_encoding","","Sets encoding for any column.",79,[[["self"],["encoding"]],["self"]]],[11,"set_compression","","Sets compression codec for any column.",79,[[["self"],["compression"]],["self"]]],[11,"set_dictionary_enabled","","Sets flag to enable/disable dictionary encoding for any column.",79,[[["self"],["bool"]],["self"]]],[11,"set_statistics_enabled","","Sets flag to enable/disable statistics for any column.",79,[[["self"],["bool"]],["self"]]],[11,"set_max_statistics_size","","Sets max statistics size for any column. Applicable only if statistics are enabled.",79,[[["self"],["usize"]],["self"]]],[11,"set_column_encoding","","Sets encoding for a column. Takes precedence over globally defined settings.",79,[[["self"],["columnpath"],["encoding"]],["self"]]],[11,"set_column_compression","","Sets compression codec for a column. Takes precedence over globally defined settings.",79,[[["self"],["columnpath"],["compression"]],["self"]]],[11,"set_column_dictionary_enabled","","Sets flag to enable/disable dictionary encoding for a column. Takes precedence over globally defined settings.",79,[[["self"],["columnpath"],["bool"]],["self"]]],[11,"set_column_statistics_enabled","","Sets flag to enable/disable statistics for a column. Takes precedence over globally defined settings.",79,[[["self"],["columnpath"],["bool"]],["self"]]],[11,"set_column_max_statistics_size","","Sets max size for statistics for a column. Takes precedence over globally defined settings.",79,[[["self"],["columnpath"],["usize"]],["self"]]],[0,"reader","parquet::file","Contains file reader API, and provides methods to access file metadata, row group readers to read individual column chunks, or access record iterator.",N,N],[3,"SerializedFileReader","parquet::file::reader","A serialized implementation for Parquet [`FileReader`].",N,N],[3,"SerializedRowGroupReader","","A serialized implementation for Parquet [`RowGroupReader`].",N,N],[3,"SerializedPageReader","","A serialized implementation for Parquet [`PageReader`].",N,N],[8,"FileReader","","Parquet file reader API. With this, user can get metadata information about the Parquet file, can get reader for each row group, and access record iterator.",N,N],[10,"metadata","","Get metadata information about this file.",80,[[["self"]],["parquetmetadataptr"]]],[10,"num_row_groups","","Get the total number of row groups for this file.",80,[[["self"]],["usize"]]],[10,"get_row_group","","Get the `i`th row group reader. Note this doesn't do bound check.",80,[[["self"],["usize"]],["result",["box"]]]],[10,"get_row_iter","","Get full iterator of `Row`s from a file (over all row groups).",80,[[["self"],["option",["schematype"]]],["result",["rowiter"]]]],[8,"RowGroupReader","","Parquet row group reader API. With this, user can get metadata information about the row group, as well as readers for each individual column chunk.",N,N],[10,"metadata","","Get metadata information about this row group.",81,[[["self"]],["rowgroupmetadataptr"]]],[10,"num_columns","","Get the total number of column chunks in this row group.",81,[[["self"]],["usize"]]],[10,"get_column_page_reader","","Get page reader for the `i`th column chunk.",81,[[["self"],["usize"]],["result",["box"]]]],[10,"get_column_reader","","Get value reader for the `i`th column chunk.",81,[[["self"],["usize"]],["result",["columnreader"]]]],[10,"get_row_iter","","Get iterator of `Row`s from this row group.",81,[[["self"],["option",["schematype"]]],["result",["rowiter"]]]],[8,"Length","","Length should return the amount of bytes that implementor contains. It's mainly used to read the metadata, which is at the end of the source.",N,N],[10,"len","","Returns the amount of bytes of the inner source.",82,[[["self"]],["u64"]]],[8,"TryClone","","TryClone tries to clone the type and should maintain the `Seek` position of the given instance.",N,N],[10,"try_clone","","Clones the type returning a new instance or an error if it's not possible to clone it.",83,[[["self"]],["result"]]],[8,"ParquetReader","","ParquetReader is the interface which needs to be fulfilled to be able to parse a parquet source.",N,N],[11,"new","","Creates file reader from a Parquet file. Returns error if Parquet file does not exist or is corrupt.",84,[[["r"]],["result"]]],[11,"metadata","","",84,[[["self"]],["parquetmetadataptr"]]],[11,"num_row_groups","","",84,[[["self"]],["usize"]]],[11,"get_row_group","","",84,[[["self"],["usize"]],["result",["box"]]]],[11,"get_row_iter","","",84,[[["self"],["option",["schematype"]]],["result",["rowiter"]]]],[11,"try_from","","",84,[[["file"]],["result"]]],[11,"try_from","","",84,[[["path"]],["result"]]],[11,"try_from","","",84,[[["string"]],["result"]]],[11,"try_from","","",84,[[["str"]],["result"]]],[11,"metadata","","",85,[[["self"]],["rowgroupmetadataptr"]]],[11,"num_columns","","",85,[[["self"]],["usize"]]],[11,"get_column_page_reader","","",85,[[["self"],["usize"]],["result",["box"]]]],[11,"get_column_reader","","",85,[[["self"],["usize"]],["result",["columnreader"]]]],[11,"get_row_iter","","",85,[[["self"],["option",["schematype"]]],["result",["rowiter"]]]],[11,"new","","Creates a new serialized page reader from file source.",86,[[["t"],["i64"],["compression"],["type"]],["result"]]],[11,"get_next_page","","",86,[[["self"]],["result",["option"]]]],[0,"writer","parquet::file","",N,N],[3,"SerializedPageWriter","parquet::file::writer","Serialized page writer.",N,N],[11,"new","","Creates new page writer.",87,[[["t"]],["self"]]],[11,"write_page","","",87,[[["self"],["compressedpage"]],["result",["pagewritespec"]]]],[11,"write_metadata","","",87,[[["self"],["columnchunkmetadata"]],["result"]]],[11,"close","","",87,[[["self"]],["result"]]],[0,"statistics","parquet::file","Contains definitions for working with Parquet statistics.",N,N],[3,"TypedStatistics","parquet::file::statistics","Typed implementation for [`Statistics`].",N,N],[4,"Statistics","","Statistics for a column chunk and data page.",N,N],[13,"Boolean","","",88,N],[13,"Int32","","",88,N],[13,"Int64","","",88,N],[13,"Int96","","",88,N],[13,"Float","","",88,N],[13,"Double","","",88,N],[13,"ByteArray","","",88,N],[13,"FixedLenByteArray","","",88,N],[5,"from_thrift","","Converts Thrift definition into `Statistics`.",N,[[["type"],["option",["tstatistics"]]],["option",["statistics"]]]],[5,"to_thrift","","",N,[[["option",["statistics"]]],["option",["tstatistics"]]]],[11,"fmt","","",88,[[["self"],["formatter"]],["result"]]],[11,"eq","","",88,[[["self"],["statistics"]],["bool"]]],[11,"ne","","",88,[[["self"],["statistics"]],["bool"]]],[11,"boolean","","",88,[[["option",["bool"]],["option",["bool"]],["option",["u64"]],["u64"],["bool"]],["self"]]],[11,"int32","","",88,[[["option",["i32"]],["option",["i32"]],["option",["u64"]],["u64"],["bool"]],["self"]]],[11,"int64","","",88,[[["option",["i64"]],["option",["i64"]],["option",["u64"]],["u64"],["bool"]],["self"]]],[11,"int96","","",88,[[["option",["int96"]],["option",["int96"]],["option",["u64"]],["u64"],["bool"]],["self"]]],[11,"float","","",88,[[["option",["f32"]],["option",["f32"]],["option",["u64"]],["u64"],["bool"]],["self"]]],[11,"double","","",88,[[["option",["f64"]],["option",["f64"]],["option",["u64"]],["u64"],["bool"]],["self"]]],[11,"byte_array","","",88,[[["option",["bytearray"]],["option",["bytearray"]],["option",["u64"]],["u64"],["bool"]],["self"]]],[11,"fixed_len_byte_array","","",88,[[["option",["bytearray"]],["option",["bytearray"]],["option",["u64"]],["u64"],["bool"]],["self"]]],[11,"is_min_max_deprecated","","Returns `true` if statistics have old `min` and `max` fields set. This means that the column order is likely to be undefined, which, for old files could mean a signed sort order of values.",88,[[["self"]],["bool"]]],[11,"distinct_count","","Returns optional value of number of distinct values occurring. When it is `None`, the value should be ignored.",88,[[["self"]],["option",["u64"]]]],[11,"null_count","","Returns number of null values for the column. Note that this includes all nulls when column is part of the complex type.",88,[[["self"]],["u64"]]],[11,"has_nulls","","Returns `true` if statistics collected any null values, `false` otherwise.",88,[[["self"]],["bool"]]],[11,"has_min_max_set","","Returns `true` if min value and max value are set. Normally both min/max values will be set to `Some(value)` or `None`.",88,[[["self"]],["bool"]]],[11,"min_bytes","","Returns slice of bytes that represent min value. Panics if min value is not set.",88,N],[11,"max_bytes","","Returns slice of bytes that represent max value. Panics if max value is not set.",88,N],[11,"physical_type","","Returns physical type associated with statistics.",88,[[["self"]],["type"]]],[11,"new","","Creates new typed statistics.",89,[[["option"],["option"],["option",["u64"]],["u64"],["bool"]],["self"]]],[11,"min","","Returns min value of the statistics.",89,N],[11,"max","","Returns max value of the statistics.",89,N],[11,"min_bytes","","Returns min value as bytes of the statistics.",89,N],[11,"max_bytes","","Returns max value as bytes of the statistics.",89,N],[11,"fmt","","",89,[[["self"],["formatter"]],["result"]]],[11,"eq","","",89,[[["self"],["typedstatistics"]],["bool"]]],[11,"into","parquet::errors","",0,[[["self"]],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"not_found","","",0,[[["str"],["str"]],["e"]]],[11,"into","parquet::basic","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_from","","",1,[[["str"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"not_found","","",1,[[["str"],["str"]],["e"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"try_from","","",2,[[["str"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"not_found","","",2,[[["str"],["str"]],["e"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"to_string","","",3,[[["self"]],["string"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"try_from","","",3,[[["str"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"not_found","","",3,[[["str"],["str"]],["e"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"to_string","","",4,[[["self"]],["string"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"not_found","","",4,[[["str"],["str"]],["e"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"to_string","","",5,[[["self"]],["string"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"not_found","","",5,[[["str"],["str"]],["e"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"to_string","","",6,[[["self"]],["string"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"not_found","","",6,[[["str"],["str"]],["e"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"to_string","","",7,[[["self"]],["string"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"not_found","","",7,[[["str"],["str"]],["e"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"to_string","","",8,[[["self"]],["string"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"not_found","","",8,[[["str"],["str"]],["e"]]],[11,"into","parquet::data_type","",12,[[["self"]],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,N],[11,"from","","",12,[[["t"]],["t"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"not_found","","",12,[[["str"],["str"]],["e"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,N],[11,"from","","",13,[[["t"]],["t"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"not_found","","",13,[[["str"],["str"]],["e"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"not_found","","",14,[[["str"],["str"]],["e"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"not_found","","",15,[[["str"],["str"]],["e"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"not_found","","",16,[[["str"],["str"]],["e"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"not_found","","",17,[[["str"],["str"]],["e"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"not_found","","",18,[[["str"],["str"]],["e"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"not_found","","",19,[[["str"],["str"]],["e"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"not_found","","",20,[[["str"],["str"]],["e"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"not_found","","",21,[[["str"],["str"]],["e"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"not_found","","",9,[[["str"],["str"]],["e"]]],[11,"into","parquet::compression","",40,[[["self"]],["u"]]],[11,"from","","",40,[[["t"]],["t"]]],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"not_found","","",40,[[["str"],["str"]],["e"]]],[11,"into","","",41,[[["self"]],["u"]]],[11,"from","","",41,[[["t"]],["t"]]],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"not_found","","",41,[[["str"],["str"]],["e"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"from","","",42,[[["t"]],["t"]]],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"not_found","","",42,[[["str"],["str"]],["e"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"from","","",43,[[["t"]],["t"]]],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"not_found","","",43,[[["str"],["str"]],["e"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"from","","",44,[[["t"]],["t"]]],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"not_found","","",44,[[["str"],["str"]],["e"]]],[11,"into","parquet::column::page","",49,[[["self"]],["u"]]],[11,"from","","",49,[[["t"]],["t"]]],[11,"try_from","","",49,[[["u"]],["result"]]],[11,"borrow","","",49,[[["self"]],["t"]]],[11,"get_type_id","","",49,[[["self"]],["typeid"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"borrow_mut","","",49,[[["self"]],["t"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"not_found","","",49,[[["str"],["str"]],["e"]]],[11,"into","","",45,[[["self"]],["u"]]],[11,"from","","",45,[[["t"]],["t"]]],[11,"try_from","","",45,[[["u"]],["result"]]],[11,"borrow","","",45,[[["self"]],["t"]]],[11,"get_type_id","","",45,[[["self"]],["typeid"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"borrow_mut","","",45,[[["self"]],["t"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"not_found","","",45,[[["str"],["str"]],["e"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"from","","",46,[[["t"]],["t"]]],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"not_found","","",46,[[["str"],["str"]],["e"]]],[11,"into","parquet::column::reader","",51,[[["self"]],["u"]]],[11,"from","","",51,[[["t"]],["t"]]],[11,"try_from","","",51,[[["u"]],["result"]]],[11,"borrow","","",51,[[["self"]],["t"]]],[11,"get_type_id","","",51,[[["self"]],["typeid"]]],[11,"try_into","","",51,[[["self"]],["result"]]],[11,"borrow_mut","","",51,[[["self"]],["t"]]],[11,"try_into","","",51,[[["self"]],["result"]]],[11,"not_found","","",51,[[["str"],["str"]],["e"]]],[11,"into","","",50,[[["self"]],["u"]]],[11,"from","","",50,[[["t"]],["t"]]],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"not_found","","",50,[[["str"],["str"]],["e"]]],[11,"into","parquet::column::writer","",53,[[["self"]],["u"]]],[11,"from","","",53,[[["t"]],["t"]]],[11,"try_from","","",53,[[["u"]],["result"]]],[11,"borrow","","",53,[[["self"]],["t"]]],[11,"get_type_id","","",53,[[["self"]],["typeid"]]],[11,"try_into","","",53,[[["self"]],["result"]]],[11,"borrow_mut","","",53,[[["self"]],["t"]]],[11,"try_into","","",53,[[["self"]],["result"]]],[11,"not_found","","",53,[[["str"],["str"]],["e"]]],[11,"into","","",52,[[["self"]],["u"]]],[11,"from","","",52,[[["t"]],["t"]]],[11,"try_from","","",52,[[["u"]],["result"]]],[11,"borrow","","",52,[[["self"]],["t"]]],[11,"get_type_id","","",52,[[["self"]],["typeid"]]],[11,"try_into","","",52,[[["self"]],["result"]]],[11,"borrow_mut","","",52,[[["self"]],["t"]]],[11,"try_into","","",52,[[["self"]],["result"]]],[11,"not_found","","",52,[[["str"],["str"]],["e"]]],[11,"into","parquet::record::reader","",55,[[["self"]],["u"]]],[11,"from","","",55,[[["t"]],["t"]]],[11,"try_from","","",55,[[["u"]],["result"]]],[11,"borrow","","",55,[[["self"]],["t"]]],[11,"get_type_id","","",55,[[["self"]],["typeid"]]],[11,"try_into","","",55,[[["self"]],["result"]]],[11,"borrow_mut","","",55,[[["self"]],["t"]]],[11,"try_into","","",55,[[["self"]],["result"]]],[11,"not_found","","",55,[[["str"],["str"]],["e"]]],[11,"into","","",56,[[["self"]],["u"]]],[11,"into_iter","","",56,[[["self"]],["i"]]],[11,"from","","",56,[[["t"]],["t"]]],[11,"try_from","","",56,[[["u"]],["result"]]],[11,"borrow","","",56,[[["self"]],["t"]]],[11,"get_type_id","","",56,[[["self"]],["typeid"]]],[11,"try_into","","",56,[[["self"]],["result"]]],[11,"borrow_mut","","",56,[[["self"]],["t"]]],[11,"try_into","","",56,[[["self"]],["result"]]],[11,"not_found","","",56,[[["str"],["str"]],["e"]]],[11,"into","","",57,[[["self"]],["u"]]],[11,"into_iter","","",57,[[["self"]],["i"]]],[11,"from","","",57,[[["t"]],["t"]]],[11,"try_from","","",57,[[["u"]],["result"]]],[11,"borrow","","",57,[[["self"]],["t"]]],[11,"get_type_id","","",57,[[["self"]],["typeid"]]],[11,"try_into","","",57,[[["self"]],["result"]]],[11,"borrow_mut","","",57,[[["self"]],["t"]]],[11,"try_into","","",57,[[["self"]],["result"]]],[11,"not_found","","",57,[[["str"],["str"]],["e"]]],[11,"into","","",54,[[["self"]],["u"]]],[11,"to_string","","",54,[[["self"]],["string"]]],[11,"from","","",54,[[["t"]],["t"]]],[11,"try_from","","",54,[[["u"]],["result"]]],[11,"borrow","","",54,[[["self"]],["t"]]],[11,"get_type_id","","",54,[[["self"]],["typeid"]]],[11,"try_into","","",54,[[["self"]],["result"]]],[11,"borrow_mut","","",54,[[["self"]],["t"]]],[11,"try_into","","",54,[[["self"]],["result"]]],[11,"not_found","","",54,[[["str"],["str"]],["e"]]],[11,"into","parquet::schema::types","",65,[[["self"]],["u"]]],[11,"from","","",65,[[["t"]],["t"]]],[11,"try_from","","",65,[[["u"]],["result"]]],[11,"borrow","","",65,[[["self"]],["t"]]],[11,"get_type_id","","",65,[[["self"]],["typeid"]]],[11,"try_into","","",65,[[["self"]],["result"]]],[11,"borrow_mut","","",65,[[["self"]],["t"]]],[11,"try_into","","",65,[[["self"]],["result"]]],[11,"not_found","","",65,[[["str"],["str"]],["e"]]],[11,"into","","",66,[[["self"]],["u"]]],[11,"from","","",66,[[["t"]],["t"]]],[11,"try_from","","",66,[[["u"]],["result"]]],[11,"borrow","","",66,[[["self"]],["t"]]],[11,"get_type_id","","",66,[[["self"]],["typeid"]]],[11,"try_into","","",66,[[["self"]],["result"]]],[11,"borrow_mut","","",66,[[["self"]],["t"]]],[11,"try_into","","",66,[[["self"]],["result"]]],[11,"not_found","","",66,[[["str"],["str"]],["e"]]],[11,"into","","",67,[[["self"]],["u"]]],[11,"from","","",67,[[["t"]],["t"]]],[11,"try_from","","",67,[[["u"]],["result"]]],[11,"borrow","","",67,[[["self"]],["t"]]],[11,"get_type_id","","",67,[[["self"]],["typeid"]]],[11,"try_into","","",67,[[["self"]],["result"]]],[11,"borrow_mut","","",67,[[["self"]],["t"]]],[11,"try_into","","",67,[[["self"]],["result"]]],[11,"not_found","","",67,[[["str"],["str"]],["e"]]],[11,"into","","",68,[[["self"]],["u"]]],[11,"to_owned","","",68,[[["self"]],["t"]]],[11,"clone_into","","",68,N],[11,"to_string","","",68,[[["self"]],["string"]]],[11,"from","","",68,[[["t"]],["t"]]],[11,"try_from","","",68,[[["u"]],["result"]]],[11,"borrow","","",68,[[["self"]],["t"]]],[11,"get_type_id","","",68,[[["self"]],["typeid"]]],[11,"try_into","","",68,[[["self"]],["result"]]],[11,"borrow_mut","","",68,[[["self"]],["t"]]],[11,"try_into","","",68,[[["self"]],["result"]]],[11,"not_found","","",68,[[["str"],["str"]],["e"]]],[11,"into","","",69,[[["self"]],["u"]]],[11,"from","","",69,[[["t"]],["t"]]],[11,"try_from","","",69,[[["u"]],["result"]]],[11,"borrow","","",69,[[["self"]],["t"]]],[11,"get_type_id","","",69,[[["self"]],["typeid"]]],[11,"try_into","","",69,[[["self"]],["result"]]],[11,"borrow_mut","","",69,[[["self"]],["t"]]],[11,"try_into","","",69,[[["self"]],["result"]]],[11,"not_found","","",69,[[["str"],["str"]],["e"]]],[11,"into","","",70,[[["self"]],["u"]]],[11,"from","","",70,[[["t"]],["t"]]],[11,"try_from","","",70,[[["u"]],["result"]]],[11,"borrow","","",70,[[["self"]],["t"]]],[11,"get_type_id","","",70,[[["self"]],["typeid"]]],[11,"try_into","","",70,[[["self"]],["result"]]],[11,"borrow_mut","","",70,[[["self"]],["t"]]],[11,"try_into","","",70,[[["self"]],["result"]]],[11,"not_found","","",70,[[["str"],["str"]],["e"]]],[11,"into","","",64,[[["self"]],["u"]]],[11,"from","","",64,[[["t"]],["t"]]],[11,"try_from","","",64,[[["u"]],["result"]]],[11,"borrow","","",64,[[["self"]],["t"]]],[11,"get_type_id","","",64,[[["self"]],["typeid"]]],[11,"try_into","","",64,[[["self"]],["result"]]],[11,"borrow_mut","","",64,[[["self"]],["t"]]],[11,"try_into","","",64,[[["self"]],["result"]]],[11,"not_found","","",64,[[["str"],["str"]],["e"]]],[11,"into","parquet::file::metadata","",71,[[["self"]],["u"]]],[11,"from","","",71,[[["t"]],["t"]]],[11,"try_from","","",71,[[["u"]],["result"]]],[11,"borrow","","",71,[[["self"]],["t"]]],[11,"get_type_id","","",71,[[["self"]],["typeid"]]],[11,"try_into","","",71,[[["self"]],["result"]]],[11,"borrow_mut","","",71,[[["self"]],["t"]]],[11,"try_into","","",71,[[["self"]],["result"]]],[11,"not_found","","",71,[[["str"],["str"]],["e"]]],[11,"into","","",72,[[["self"]],["u"]]],[11,"from","","",72,[[["t"]],["t"]]],[11,"try_from","","",72,[[["u"]],["result"]]],[11,"borrow","","",72,[[["self"]],["t"]]],[11,"get_type_id","","",72,[[["self"]],["typeid"]]],[11,"try_into","","",72,[[["self"]],["result"]]],[11,"borrow_mut","","",72,[[["self"]],["t"]]],[11,"try_into","","",72,[[["self"]],["result"]]],[11,"not_found","","",72,[[["str"],["str"]],["e"]]],[11,"into","","",73,[[["self"]],["u"]]],[11,"from","","",73,[[["t"]],["t"]]],[11,"try_from","","",73,[[["u"]],["result"]]],[11,"borrow","","",73,[[["self"]],["t"]]],[11,"get_type_id","","",73,[[["self"]],["typeid"]]],[11,"try_into","","",73,[[["self"]],["result"]]],[11,"borrow_mut","","",73,[[["self"]],["t"]]],[11,"try_into","","",73,[[["self"]],["result"]]],[11,"not_found","","",73,[[["str"],["str"]],["e"]]],[11,"into","","",74,[[["self"]],["u"]]],[11,"from","","",74,[[["t"]],["t"]]],[11,"try_from","","",74,[[["u"]],["result"]]],[11,"borrow","","",74,[[["self"]],["t"]]],[11,"get_type_id","","",74,[[["self"]],["typeid"]]],[11,"try_into","","",74,[[["self"]],["result"]]],[11,"borrow_mut","","",74,[[["self"]],["t"]]],[11,"try_into","","",74,[[["self"]],["result"]]],[11,"not_found","","",74,[[["str"],["str"]],["e"]]],[11,"into","","",75,[[["self"]],["u"]]],[11,"from","","",75,[[["t"]],["t"]]],[11,"try_from","","",75,[[["u"]],["result"]]],[11,"borrow","","",75,[[["self"]],["t"]]],[11,"get_type_id","","",75,[[["self"]],["typeid"]]],[11,"try_into","","",75,[[["self"]],["result"]]],[11,"borrow_mut","","",75,[[["self"]],["t"]]],[11,"try_into","","",75,[[["self"]],["result"]]],[11,"not_found","","",75,[[["str"],["str"]],["e"]]],[11,"into","","",76,[[["self"]],["u"]]],[11,"from","","",76,[[["t"]],["t"]]],[11,"try_from","","",76,[[["u"]],["result"]]],[11,"borrow","","",76,[[["self"]],["t"]]],[11,"get_type_id","","",76,[[["self"]],["typeid"]]],[11,"try_into","","",76,[[["self"]],["result"]]],[11,"borrow_mut","","",76,[[["self"]],["t"]]],[11,"try_into","","",76,[[["self"]],["result"]]],[11,"not_found","","",76,[[["str"],["str"]],["e"]]],[11,"into","parquet::file::properties","",78,[[["self"]],["u"]]],[11,"to_owned","","",78,[[["self"]],["t"]]],[11,"clone_into","","",78,N],[11,"from","","",78,[[["t"]],["t"]]],[11,"try_from","","",78,[[["u"]],["result"]]],[11,"borrow","","",78,[[["self"]],["t"]]],[11,"get_type_id","","",78,[[["self"]],["typeid"]]],[11,"try_into","","",78,[[["self"]],["result"]]],[11,"borrow_mut","","",78,[[["self"]],["t"]]],[11,"try_into","","",78,[[["self"]],["result"]]],[11,"not_found","","",78,[[["str"],["str"]],["e"]]],[11,"into","","",79,[[["self"]],["u"]]],[11,"from","","",79,[[["t"]],["t"]]],[11,"try_from","","",79,[[["u"]],["result"]]],[11,"borrow","","",79,[[["self"]],["t"]]],[11,"get_type_id","","",79,[[["self"]],["typeid"]]],[11,"try_into","","",79,[[["self"]],["result"]]],[11,"borrow_mut","","",79,[[["self"]],["t"]]],[11,"try_into","","",79,[[["self"]],["result"]]],[11,"not_found","","",79,[[["str"],["str"]],["e"]]],[11,"into","","",77,[[["self"]],["u"]]],[11,"to_owned","","",77,[[["self"]],["t"]]],[11,"clone_into","","",77,N],[11,"from","","",77,[[["t"]],["t"]]],[11,"try_from","","",77,[[["u"]],["result"]]],[11,"borrow","","",77,[[["self"]],["t"]]],[11,"get_type_id","","",77,[[["self"]],["typeid"]]],[11,"try_into","","",77,[[["self"]],["result"]]],[11,"borrow_mut","","",77,[[["self"]],["t"]]],[11,"try_into","","",77,[[["self"]],["result"]]],[11,"not_found","","",77,[[["str"],["str"]],["e"]]],[11,"into","parquet::file::reader","",84,[[["self"]],["u"]]],[11,"from","","",84,[[["t"]],["t"]]],[11,"try_from","","",84,[[["u"]],["result"]]],[11,"borrow","","",84,[[["self"]],["t"]]],[11,"get_type_id","","",84,[[["self"]],["typeid"]]],[11,"try_into","","",84,[[["self"]],["result"]]],[11,"borrow_mut","","",84,[[["self"]],["t"]]],[11,"try_into","","",84,[[["self"]],["result"]]],[11,"not_found","","",84,[[["str"],["str"]],["e"]]],[11,"into","","",85,[[["self"]],["u"]]],[11,"from","","",85,[[["t"]],["t"]]],[11,"try_from","","",85,[[["u"]],["result"]]],[11,"borrow","","",85,[[["self"]],["t"]]],[11,"get_type_id","","",85,[[["self"]],["typeid"]]],[11,"try_into","","",85,[[["self"]],["result"]]],[11,"borrow_mut","","",85,[[["self"]],["t"]]],[11,"try_into","","",85,[[["self"]],["result"]]],[11,"not_found","","",85,[[["str"],["str"]],["e"]]],[11,"into","","",86,[[["self"]],["u"]]],[11,"from","","",86,[[["t"]],["t"]]],[11,"try_from","","",86,[[["u"]],["result"]]],[11,"borrow","","",86,[[["self"]],["t"]]],[11,"get_type_id","","",86,[[["self"]],["typeid"]]],[11,"try_into","","",86,[[["self"]],["result"]]],[11,"borrow_mut","","",86,[[["self"]],["t"]]],[11,"try_into","","",86,[[["self"]],["result"]]],[11,"not_found","","",86,[[["str"],["str"]],["e"]]],[11,"into","parquet::file::writer","",87,[[["self"]],["u"]]],[11,"from","","",87,[[["t"]],["t"]]],[11,"try_from","","",87,[[["u"]],["result"]]],[11,"borrow","","",87,[[["self"]],["t"]]],[11,"get_type_id","","",87,[[["self"]],["typeid"]]],[11,"try_into","","",87,[[["self"]],["result"]]],[11,"borrow_mut","","",87,[[["self"]],["t"]]],[11,"try_into","","",87,[[["self"]],["result"]]],[11,"not_found","","",87,[[["str"],["str"]],["e"]]],[11,"into","parquet::file::statistics","",89,[[["self"]],["u"]]],[11,"from","","",89,[[["t"]],["t"]]],[11,"try_from","","",89,[[["u"]],["result"]]],[11,"borrow","","",89,[[["self"]],["t"]]],[11,"get_type_id","","",89,[[["self"]],["typeid"]]],[11,"try_into","","",89,[[["self"]],["result"]]],[11,"borrow_mut","","",89,[[["self"]],["t"]]],[11,"try_into","","",89,[[["self"]],["result"]]],[11,"not_found","","",89,[[["str"],["str"]],["e"]]],[11,"into","","",88,[[["self"]],["u"]]],[11,"from","","",88,[[["t"]],["t"]]],[11,"try_from","","",88,[[["u"]],["result"]]],[11,"borrow","","",88,[[["self"]],["t"]]],[11,"get_type_id","","",88,[[["self"]],["typeid"]]],[11,"try_into","","",88,[[["self"]],["result"]]],[11,"borrow_mut","","",88,[[["self"]],["t"]]],[11,"try_into","","",88,[[["self"]],["result"]]],[11,"not_found","","",88,[[["str"],["str"]],["e"]]]],"paths":[[4,"ParquetError"],[4,"Type"],[4,"LogicalType"],[4,"Repetition"],[4,"Encoding"],[4,"Compression"],[4,"PageType"],[4,"SortOrder"],[4,"ColumnOrder"],[4,"Decimal"],[8,"AsBytes"],[8,"DataType"],[3,"Int96"],[3,"ByteArray"],[3,"BoolType"],[3,"Int32Type"],[3,"Int64Type"],[3,"Int96Type"],[3,"FloatType"],[3,"DoubleType"],[3,"ByteArrayType"],[3,"FixedLenByteArrayType"],[8,"Encoder"],[8,"Decoder"],[3,"MemTracker"],[3,"Buffer"],[3,"BufferPtr"],[3,"PlainEncoder"],[3,"DictEncoder"],[3,"RleValueEncoder"],[3,"DeltaBitPackEncoder"],[3,"DeltaLengthByteArrayEncoder"],[3,"DeltaByteArrayEncoder"],[3,"PlainDecoder"],[3,"DictDecoder"],[3,"RleValueDecoder"],[3,"DeltaBitPackDecoder"],[3,"DeltaLengthByteArrayDecoder"],[3,"DeltaByteArrayDecoder"],[8,"Codec"],[3,"SnappyCodec"],[3,"GZipCodec"],[3,"BrotliCodec"],[3,"LZ4Codec"],[3,"ZSTDCodec"],[3,"PageWriteSpec"],[4,"Page"],[8,"PageReader"],[8,"PageWriter"],[3,"CompressedPage"],[4,"ColumnReader"],[3,"ColumnReaderImpl"],[4,"ColumnWriter"],[3,"ColumnWriterImpl"],[4,"Reader"],[3,"TreeBuilder"],[3,"RowIter"],[3,"ReaderIter"],[3,"Row"],[3,"List"],[3,"Map"],[8,"RowAccessor"],[8,"ListAccessor"],[8,"MapAccessor"],[4,"Type"],[3,"PrimitiveTypeBuilder"],[3,"GroupTypeBuilder"],[3,"BasicTypeInfo"],[3,"ColumnPath"],[3,"ColumnDescriptor"],[3,"SchemaDescriptor"],[3,"ParquetMetaData"],[3,"FileMetaData"],[3,"RowGroupMetaData"],[3,"RowGroupMetaDataBuilder"],[3,"ColumnChunkMetaData"],[3,"ColumnChunkMetaDataBuilder"],[4,"WriterVersion"],[3,"WriterProperties"],[3,"WriterPropertiesBuilder"],[8,"FileReader"],[8,"RowGroupReader"],[8,"Length"],[8,"TryClone"],[3,"SerializedFileReader"],[3,"SerializedRowGroupReader"],[3,"SerializedPageReader"],[3,"SerializedPageWriter"],[4,"Statistics"],[3,"TypedStatistics"]]};
searchIndex["parquet_read"]={"doc":"Binary file to read data from a Parquet file.","items":[],"paths":[]};
searchIndex["parquet_schema"]={"doc":"Binary file to print the schema and metadata of a Parquet file.","items":[],"paths":[]};
initSearch(searchIndex);
