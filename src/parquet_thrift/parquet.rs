// Autogenerated by Thrift Compiler (1.0.0-dev)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]

extern crate ordered_float;
extern crate thrift;
extern crate try_from;

use ordered_float::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::From;
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;
use try_from::TryFrom;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

/// Types supported by Parquet.  These types are intended to be used in combination
/// with the encodings to control the on disk storage format.
/// For example INT16 is not included as a type since a good encoding of INT32
/// would handle this.
#[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub enum Type {
  BOOLEAN = 0,
  INT32 = 1,
  INT64 = 2,
  INT96 = 3,
  FLOAT = 4,
  DOUBLE = 5,
  BYTE_ARRAY = 6,
  FIXED_LEN_BYTE_ARRAY = 7,
}

impl Type {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<Type> {
    let enum_value = i_prot.read_i32()?;
    Type::try_from(enum_value)  }
}

impl TryFrom<i32> for Type {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(Type::BOOLEAN),
      1 => Ok(Type::INT32),
      2 => Ok(Type::INT64),
      3 => Ok(Type::INT96),
      4 => Ok(Type::FLOAT),
      5 => Ok(Type::DOUBLE),
      6 => Ok(Type::BYTE_ARRAY),
      7 => Ok(Type::FIXED_LEN_BYTE_ARRAY),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to Type", i)
            )
          )
        )
      },
    }
  }
}

/// Common types used by frameworks(e.g. hive, pig) using parquet.  This helps map
/// between types in those frameworks to the base types in parquet.  This is only
/// metadata and not needed to read or write the data.
#[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub enum ConvertedType {
  /// a BYTE_ARRAY actually contains UTF8 encoded chars
  UTF8 = 0,
  /// a map is converted as an optional field containing a repeated key/value pair
  MAP = 1,
  /// a key/value pair is converted into a group of two fields
  MAP_KEY_VALUE = 2,
  /// a list is converted into an optional field containing a repeated field for its
  /// values
  LIST = 3,
  /// an enum is converted into a binary field
  ENUM = 4,
  /// A decimal value.
  /// 
  /// This may be used to annotate binary or fixed primitive types. The
  /// underlying byte array stores the unscaled value encoded as two's
  /// complement using big-endian byte order (the most significant byte is the
  /// zeroth element). The value of the decimal is the value * 10^{-scale}.
  /// 
  /// This must be accompanied by a (maximum) precision and a scale in the
  /// SchemaElement. The precision specifies the number of digits in the decimal
  /// and the scale stores the location of the decimal point. For example 1.23
  /// would have precision 3 (3 total digits) and scale 2 (the decimal point is
  /// 2 digits over).
  DECIMAL = 5,
  /// A Date
  /// 
  /// Stored as days since Unix epoch, encoded as the INT32 physical type.
  /// 
  DATE = 6,
  /// A time
  /// 
  /// The total number of milliseconds since midnight.  The value is stored
  /// as an INT32 physical type.
  TIME_MILLIS = 7,
  /// A time.
  /// 
  /// The total number of microseconds since midnight.  The value is stored as
  /// an INT64 physical type.
  TIME_MICROS = 8,
  /// A date/time combination
  /// 
  /// Date and time recorded as milliseconds since the Unix epoch.  Recorded as
  /// a physical type of INT64.
  TIMESTAMP_MILLIS = 9,
  /// A date/time combination
  /// 
  /// Date and time recorded as microseconds since the Unix epoch.  The value is
  /// stored as an INT64 physical type.
  TIMESTAMP_MICROS = 10,
  /// An unsigned integer value.
  /// 
  /// The number describes the maximum number of meainful data bits in
  /// the stored value. 8, 16 and 32 bit values are stored using the
  /// INT32 physical type.  64 bit values are stored using the INT64
  /// physical type.
  /// 
  UINT_8 = 11,
  UINT_16 = 12,
  UINT_32 = 13,
  UINT_64 = 14,
  /// A signed integer value.
  /// 
  /// The number describes the maximum number of meainful data bits in
  /// the stored value. 8, 16 and 32 bit values are stored using the
  /// INT32 physical type.  64 bit values are stored using the INT64
  /// physical type.
  /// 
  INT_8 = 15,
  INT_16 = 16,
  INT_32 = 17,
  INT_64 = 18,
  /// An embedded JSON document
  /// 
  /// A JSON document embedded within a single UTF8 column.
  JSON = 19,
  /// An embedded BSON document
  /// 
  /// A BSON document embedded within a single BINARY column.
  BSON = 20,
  /// An interval of time
  /// 
  /// This type annotates data stored as a FIXED_LEN_BYTE_ARRAY of length 12
  /// This data is composed of three separate little endian unsigned
  /// integers.  Each stores a component of a duration of time.  The first
  /// integer identifies the number of months associated with the duration,
  /// the second identifies the number of days associated with the duration
  /// and the third identifies the number of milliseconds associated with
  /// the provided duration.  This duration of time is independent of any
  /// particular timezone or date.
  INTERVAL = 21,
}

impl ConvertedType {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ConvertedType> {
    let enum_value = i_prot.read_i32()?;
    ConvertedType::try_from(enum_value)  }
}

impl TryFrom<i32> for ConvertedType {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(ConvertedType::UTF8),
      1 => Ok(ConvertedType::MAP),
      2 => Ok(ConvertedType::MAP_KEY_VALUE),
      3 => Ok(ConvertedType::LIST),
      4 => Ok(ConvertedType::ENUM),
      5 => Ok(ConvertedType::DECIMAL),
      6 => Ok(ConvertedType::DATE),
      7 => Ok(ConvertedType::TIME_MILLIS),
      8 => Ok(ConvertedType::TIME_MICROS),
      9 => Ok(ConvertedType::TIMESTAMP_MILLIS),
      10 => Ok(ConvertedType::TIMESTAMP_MICROS),
      11 => Ok(ConvertedType::UINT_8),
      12 => Ok(ConvertedType::UINT_16),
      13 => Ok(ConvertedType::UINT_32),
      14 => Ok(ConvertedType::UINT_64),
      15 => Ok(ConvertedType::INT_8),
      16 => Ok(ConvertedType::INT_16),
      17 => Ok(ConvertedType::INT_32),
      18 => Ok(ConvertedType::INT_64),
      19 => Ok(ConvertedType::JSON),
      20 => Ok(ConvertedType::BSON),
      21 => Ok(ConvertedType::INTERVAL),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ConvertedType", i)
            )
          )
        )
      },
    }
  }
}

/// Representation of Schemas
#[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub enum FieldRepetitionType {
  /// This field is required (can not be null) and each record has exactly 1 value.
  REQUIRED = 0,
  /// The field is optional (can be null) and each record has 0 or 1 values.
  OPTIONAL = 1,
  /// The field is repeated and can contain 0 or more values
  REPEATED = 2,
}

impl FieldRepetitionType {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<FieldRepetitionType> {
    let enum_value = i_prot.read_i32()?;
    FieldRepetitionType::try_from(enum_value)  }
}

impl TryFrom<i32> for FieldRepetitionType {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(FieldRepetitionType::REQUIRED),
      1 => Ok(FieldRepetitionType::OPTIONAL),
      2 => Ok(FieldRepetitionType::REPEATED),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to FieldRepetitionType", i)
            )
          )
        )
      },
    }
  }
}

/// Encodings supported by Parquet.  Not all encodings are valid for all types.  These
/// enums are also used to specify the encoding of definition and repetition levels.
/// See the accompanying doc for the details of the more complicated encodings.
#[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub enum Encoding {
  /// Default encoding.
  /// BOOLEAN - 1 bit per value. 0 is false; 1 is true.
  /// INT32 - 4 bytes per value.  Stored as little-endian.
  /// INT64 - 8 bytes per value.  Stored as little-endian.
  /// FLOAT - 4 bytes per value.  IEEE. Stored as little-endian.
  /// DOUBLE - 8 bytes per value.  IEEE. Stored as little-endian.
  /// BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes.
  /// FIXED_LEN_BYTE_ARRAY - Just the bytes.
  PLAIN = 0,
  /// Deprecated: Dictionary encoding. The values in the dictionary are encoded in the
  /// plain type.
  /// in a data page use RLE_DICTIONARY instead.
  /// in a Dictionary page use PLAIN instead
  PLAIN_DICTIONARY = 2,
  /// Group packed run length encoding. Usable for definition/reptition levels
  /// encoding and Booleans (on one bit: 0 is false; 1 is true.)
  RLE = 3,
  /// Bit packed encoding.  This can only be used if the data has a known max
  /// width.  Usable for definition/repetition levels encoding.
  BIT_PACKED = 4,
  /// Delta encoding for integers. This can be used for int columns and works best
  /// on sorted data
  DELTA_BINARY_PACKED = 5,
  /// Encoding for byte arrays to separate the length values and the data. The lengths
  /// are encoded using DELTA_BINARY_PACKED
  DELTA_LENGTH_BYTE_ARRAY = 6,
  /// Incremental-encoded byte array. Prefix lengths are encoded using DELTA_BINARY_PACKED.
  /// Suffixes are stored as delta length byte arrays.
  DELTA_BYTE_ARRAY = 7,
  /// Dictionary encoding: the ids are encoded using the RLE encoding
  RLE_DICTIONARY = 8,
}

impl Encoding {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<Encoding> {
    let enum_value = i_prot.read_i32()?;
    Encoding::try_from(enum_value)  }
}

impl TryFrom<i32> for Encoding {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(Encoding::PLAIN),
      2 => Ok(Encoding::PLAIN_DICTIONARY),
      3 => Ok(Encoding::RLE),
      4 => Ok(Encoding::BIT_PACKED),
      5 => Ok(Encoding::DELTA_BINARY_PACKED),
      6 => Ok(Encoding::DELTA_LENGTH_BYTE_ARRAY),
      7 => Ok(Encoding::DELTA_BYTE_ARRAY),
      8 => Ok(Encoding::RLE_DICTIONARY),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to Encoding", i)
            )
          )
        )
      },
    }
  }
}

/// Supported compression algorithms.
#[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub enum CompressionCodec {
  UNCOMPRESSED = 0,
  SNAPPY = 1,
  GZIP = 2,
  LZO = 3,
  BROTLI = 4,
}

impl CompressionCodec {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<CompressionCodec> {
    let enum_value = i_prot.read_i32()?;
    CompressionCodec::try_from(enum_value)  }
}

impl TryFrom<i32> for CompressionCodec {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(CompressionCodec::UNCOMPRESSED),
      1 => Ok(CompressionCodec::SNAPPY),
      2 => Ok(CompressionCodec::GZIP),
      3 => Ok(CompressionCodec::LZO),
      4 => Ok(CompressionCodec::BROTLI),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to CompressionCodec", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub enum PageType {
  DATA_PAGE = 0,
  INDEX_PAGE = 1,
  DICTIONARY_PAGE = 2,
  DATA_PAGE_V2 = 3,
}

impl PageType {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<PageType> {
    let enum_value = i_prot.read_i32()?;
    PageType::try_from(enum_value)  }
}

impl TryFrom<i32> for PageType {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(PageType::DATA_PAGE),
      1 => Ok(PageType::INDEX_PAGE),
      2 => Ok(PageType::DICTIONARY_PAGE),
      3 => Ok(PageType::DATA_PAGE_V2),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to PageType", i)
            )
          )
        )
      },
    }
  }
}

//
// Statistics
//

/// Statistics per row group and per page
/// All fields are optional.
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct Statistics {
  /// min and max value of the column, encoded in PLAIN encoding
  pub max: Option<Vec<u8>>,
  pub min: Option<Vec<u8>>,
  /// count of null value in the column
  pub null_count: Option<i64>,
  /// count of distinct values occurring
  pub distinct_count: Option<i64>,
}

impl Statistics {
  pub fn new<F1, F2, F3, F4>(max: F1, min: F2, null_count: F3, distinct_count: F4) -> Statistics where F1: Into<Option<Vec<u8>>>, F2: Into<Option<Vec<u8>>>, F3: Into<Option<i64>>, F4: Into<Option<i64>> {
    Statistics {
      max: max.into(),
      min: min.into(),
      null_count: null_count.into(),
      distinct_count: distinct_count.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<Statistics> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Statistics {
      max: f_1,
      min: f_2,
      null_count: f_3,
      distinct_count: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Statistics");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.max {
      o_prot.write_field_begin(&TFieldIdentifier::new("max", TType::String, 1))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.min {
      o_prot.write_field_begin(&TFieldIdentifier::new("min", TType::String, 2))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.null_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("null_count", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.distinct_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("distinct_count", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Statistics {
  fn default() -> Self {
    Statistics{
      max: Some(Vec::new()),
      min: Some(Vec::new()),
      null_count: Some(0),
      distinct_count: Some(0),
    }
  }
}

//
// SchemaElement
//

/// Represents a element inside a schema definition.
///  - if it is a group (inner node) then type is undefined and num_children is defined
///  - if it is a primitive type (leaf) then type is defined and num_children is undefined
/// the nodes are listed in depth first traversal order.
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct SchemaElement {
  /// Data type for this field. Not set if the current element is a non-leaf node
  pub type_: Option<Type>,
  /// If type is FIXED_LEN_BYTE_ARRAY, this is the byte length of the vales.
  /// Otherwise, if specified, this is the maximum bit length to store any of the values.
  /// (e.g. a low cardinality INT col could have this set to 3).  Note that this is
  /// in the schema, and therefore fixed for the entire file.
  pub type_length: Option<i32>,
  /// repetition of the field. The root of the schema does not have a repetition_type.
  /// All other nodes must have one
  pub repetition_type: Option<FieldRepetitionType>,
  /// Name of the field in the schema
  pub name: String,
  /// Nested fields.  Since thrift does not support nested fields,
  /// the nesting is flattened to a single list by a depth-first traversal.
  /// The children count is used to construct the nested relationship.
  /// This field is not set when the element is a primitive type
  pub num_children: Option<i32>,
  /// When the schema is the result of a conversion from another model
  /// Used to record the original type to help with cross conversion.
  pub converted_type: Option<ConvertedType>,
  /// Used when this column contains decimal data.
  /// See the DECIMAL converted type for more details.
  pub scale: Option<i32>,
  pub precision: Option<i32>,
  /// When the original schema supports field ids, this will save the
  /// original field id in the parquet schema
  pub field_id: Option<i32>,
}

impl SchemaElement {
  pub fn new<F1, F2, F3, F5, F6, F7, F8, F9>(type_: F1, type_length: F2, repetition_type: F3, name: String, num_children: F5, converted_type: F6, scale: F7, precision: F8, field_id: F9) -> SchemaElement where F1: Into<Option<Type>>, F2: Into<Option<i32>>, F3: Into<Option<FieldRepetitionType>>, F5: Into<Option<i32>>, F6: Into<Option<ConvertedType>>, F7: Into<Option<i32>>, F8: Into<Option<i32>>, F9: Into<Option<i32>> {
    SchemaElement {
      type_: type_.into(),
      type_length: type_length.into(),
      repetition_type: repetition_type.into(),
      name: name,
      num_children: num_children.into(),
      converted_type: converted_type.into(),
      scale: scale.into(),
      precision: precision.into(),
      field_id: field_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SchemaElement> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Type> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<FieldRepetitionType> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<ConvertedType> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<i32> = None;
    let mut f_9: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Type::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = FieldRepetitionType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = ConvertedType::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i32()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SchemaElement.name", &f_4)?;
    let ret = SchemaElement {
      type_: f_1,
      type_length: f_2,
      repetition_type: f_3,
      name: f_4.expect("auto-generated code should have checked for presence of required fields"),
      num_children: f_5,
      converted_type: f_6,
      scale: f_7,
      precision: f_8,
      field_id: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SchemaElement");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.type_length {
      o_prot.write_field_begin(&TFieldIdentifier::new("type_length", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.repetition_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("repetition_type", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 4))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.num_children {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_children", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.converted_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("converted_type", TType::I32, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.scale {
      o_prot.write_field_begin(&TFieldIdentifier::new("scale", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.precision {
      o_prot.write_field_begin(&TFieldIdentifier::new("precision", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.field_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("field_id", TType::I32, 9))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DataPageHeader
//

/// Data page header
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct DataPageHeader {
  /// Number of values, including NULLs, in this data page. *
  pub num_values: i32,
  /// Encoding used for this data page *
  pub encoding: Encoding,
  /// Encoding used for definition levels *
  pub definition_level_encoding: Encoding,
  /// Encoding used for repetition levels *
  pub repetition_level_encoding: Encoding,
  /// Optional statistics for the data in this page*
  pub statistics: Option<Statistics>,
}

impl DataPageHeader {
  pub fn new<F5>(num_values: i32, encoding: Encoding, definition_level_encoding: Encoding, repetition_level_encoding: Encoding, statistics: F5) -> DataPageHeader where F5: Into<Option<Statistics>> {
    DataPageHeader {
      num_values: num_values,
      encoding: encoding,
      definition_level_encoding: definition_level_encoding,
      repetition_level_encoding: repetition_level_encoding,
      statistics: statistics.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<DataPageHeader> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Encoding> = None;
    let mut f_3: Option<Encoding> = None;
    let mut f_4: Option<Encoding> = None;
    let mut f_5: Option<Statistics> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Encoding::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Encoding::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Encoding::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = Statistics::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DataPageHeader.num_values", &f_1)?;
    verify_required_field_exists("DataPageHeader.encoding", &f_2)?;
    verify_required_field_exists("DataPageHeader.definition_level_encoding", &f_3)?;
    verify_required_field_exists("DataPageHeader.repetition_level_encoding", &f_4)?;
    let ret = DataPageHeader {
      num_values: f_1.expect("auto-generated code should have checked for presence of required fields"),
      encoding: f_2.expect("auto-generated code should have checked for presence of required fields"),
      definition_level_encoding: f_3.expect("auto-generated code should have checked for presence of required fields"),
      repetition_level_encoding: f_4.expect("auto-generated code should have checked for presence of required fields"),
      statistics: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DataPageHeader");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("num_values", TType::I32, 1))?;
    o_prot.write_i32(self.num_values)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encoding", TType::I32, 2))?;
    self.encoding.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("definition_level_encoding", TType::I32, 3))?;
    self.definition_level_encoding.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("repetition_level_encoding", TType::I32, 4))?;
    self.repetition_level_encoding.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.statistics {
      o_prot.write_field_begin(&TFieldIdentifier::new("statistics", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IndexPageHeader
//

#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct IndexPageHeader {
}

impl IndexPageHeader {
  pub fn new() -> IndexPageHeader {
    IndexPageHeader {}
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<IndexPageHeader> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IndexPageHeader {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IndexPageHeader");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for IndexPageHeader {
  fn default() -> Self {
    IndexPageHeader{}
  }
}

//
// DictionaryPageHeader
//

/// TODO: *
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct DictionaryPageHeader {
  /// Number of values in the dictionary *
  pub num_values: i32,
  /// Encoding using this dictionary page *
  pub encoding: Encoding,
  /// If true, the entries in the dictionary are sorted in ascending order *
  pub is_sorted: Option<bool>,
}

impl DictionaryPageHeader {
  pub fn new<F3>(num_values: i32, encoding: Encoding, is_sorted: F3) -> DictionaryPageHeader where F3: Into<Option<bool>> {
    DictionaryPageHeader {
      num_values: num_values,
      encoding: encoding,
      is_sorted: is_sorted.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<DictionaryPageHeader> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Encoding> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Encoding::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DictionaryPageHeader.num_values", &f_1)?;
    verify_required_field_exists("DictionaryPageHeader.encoding", &f_2)?;
    let ret = DictionaryPageHeader {
      num_values: f_1.expect("auto-generated code should have checked for presence of required fields"),
      encoding: f_2.expect("auto-generated code should have checked for presence of required fields"),
      is_sorted: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DictionaryPageHeader");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("num_values", TType::I32, 1))?;
    o_prot.write_i32(self.num_values)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encoding", TType::I32, 2))?;
    self.encoding.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_sorted {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_sorted", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DataPageHeaderV2
//

/// New page format alowing reading levels without decompressing the data
/// Repetition and definition levels are uncompressed
/// The remaining section containing the data is compressed if is_compressed is true
/// 
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct DataPageHeaderV2 {
  /// Number of values, including NULLs, in this data page. *
  pub num_values: i32,
  /// Number of NULL values, in this data page.
  /// Number of non-null = num_values - num_nulls which is also the number of values in the data section *
  pub num_nulls: i32,
  /// Number of rows in this data page. which means pages change on record boundaries (r = 0) *
  pub num_rows: i32,
  /// Encoding used for data in this page *
  pub encoding: Encoding,
  /// length of the repetition levels
  pub definition_levels_byte_length: i32,
  /// length of the definition levels
  pub repetition_levels_byte_length: i32,
  /// whether the values are compressed.
  /// Which means the section of the page between
  /// definition_levels_byte_length + repetition_levels_byte_length + 1 and compressed_page_size (included)
  /// is compressed with the compression_codec.
  /// If missing it is considered compressed
  pub is_compressed: Option<bool>,
  /// optional statistics for this column chunk
  pub statistics: Option<Statistics>,
}

impl DataPageHeaderV2 {
  pub fn new<F7, F8>(num_values: i32, num_nulls: i32, num_rows: i32, encoding: Encoding, definition_levels_byte_length: i32, repetition_levels_byte_length: i32, is_compressed: F7, statistics: F8) -> DataPageHeaderV2 where F7: Into<Option<bool>>, F8: Into<Option<Statistics>> {
    DataPageHeaderV2 {
      num_values: num_values,
      num_nulls: num_nulls,
      num_rows: num_rows,
      encoding: encoding,
      definition_levels_byte_length: definition_levels_byte_length,
      repetition_levels_byte_length: repetition_levels_byte_length,
      is_compressed: is_compressed.into(),
      statistics: statistics.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<DataPageHeaderV2> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<Encoding> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<Statistics> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = Encoding::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = Statistics::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DataPageHeaderV2.num_values", &f_1)?;
    verify_required_field_exists("DataPageHeaderV2.num_nulls", &f_2)?;
    verify_required_field_exists("DataPageHeaderV2.num_rows", &f_3)?;
    verify_required_field_exists("DataPageHeaderV2.encoding", &f_4)?;
    verify_required_field_exists("DataPageHeaderV2.definition_levels_byte_length", &f_5)?;
    verify_required_field_exists("DataPageHeaderV2.repetition_levels_byte_length", &f_6)?;
    let ret = DataPageHeaderV2 {
      num_values: f_1.expect("auto-generated code should have checked for presence of required fields"),
      num_nulls: f_2.expect("auto-generated code should have checked for presence of required fields"),
      num_rows: f_3.expect("auto-generated code should have checked for presence of required fields"),
      encoding: f_4.expect("auto-generated code should have checked for presence of required fields"),
      definition_levels_byte_length: f_5.expect("auto-generated code should have checked for presence of required fields"),
      repetition_levels_byte_length: f_6.expect("auto-generated code should have checked for presence of required fields"),
      is_compressed: f_7,
      statistics: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DataPageHeaderV2");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("num_values", TType::I32, 1))?;
    o_prot.write_i32(self.num_values)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("num_nulls", TType::I32, 2))?;
    o_prot.write_i32(self.num_nulls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("num_rows", TType::I32, 3))?;
    o_prot.write_i32(self.num_rows)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encoding", TType::I32, 4))?;
    self.encoding.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("definition_levels_byte_length", TType::I32, 5))?;
    o_prot.write_i32(self.definition_levels_byte_length)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("repetition_levels_byte_length", TType::I32, 6))?;
    o_prot.write_i32(self.repetition_levels_byte_length)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_compressed {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_compressed", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.statistics {
      o_prot.write_field_begin(&TFieldIdentifier::new("statistics", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PageHeader
//

#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct PageHeader {
  /// the type of the page: indicates which of the *_header fields is set *
  pub type_: PageType,
  /// Uncompressed page size in bytes (not including this header) *
  pub uncompressed_page_size: i32,
  /// Compressed page size in bytes (not including this header) *
  pub compressed_page_size: i32,
  /// 32bit crc for the data below. This allows for disabling checksumming in HDFS
  /// if only a few pages needs to be read
  /// 
  pub crc: Option<i32>,
  pub data_page_header: Option<DataPageHeader>,
  pub index_page_header: Option<IndexPageHeader>,
  pub dictionary_page_header: Option<DictionaryPageHeader>,
  pub data_page_header_v2: Option<DataPageHeaderV2>,
}

impl PageHeader {
  pub fn new<F4, F5, F6, F7, F8>(type_: PageType, uncompressed_page_size: i32, compressed_page_size: i32, crc: F4, data_page_header: F5, index_page_header: F6, dictionary_page_header: F7, data_page_header_v2: F8) -> PageHeader where F4: Into<Option<i32>>, F5: Into<Option<DataPageHeader>>, F6: Into<Option<IndexPageHeader>>, F7: Into<Option<DictionaryPageHeader>>, F8: Into<Option<DataPageHeaderV2>> {
    PageHeader {
      type_: type_,
      uncompressed_page_size: uncompressed_page_size,
      compressed_page_size: compressed_page_size,
      crc: crc.into(),
      data_page_header: data_page_header.into(),
      index_page_header: index_page_header.into(),
      dictionary_page_header: dictionary_page_header.into(),
      data_page_header_v2: data_page_header_v2.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<PageHeader> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<PageType> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<DataPageHeader> = None;
    let mut f_6: Option<IndexPageHeader> = None;
    let mut f_7: Option<DictionaryPageHeader> = None;
    let mut f_8: Option<DataPageHeaderV2> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PageType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = DataPageHeader::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = IndexPageHeader::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = DictionaryPageHeader::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = DataPageHeaderV2::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PageHeader.type_", &f_1)?;
    verify_required_field_exists("PageHeader.uncompressed_page_size", &f_2)?;
    verify_required_field_exists("PageHeader.compressed_page_size", &f_3)?;
    let ret = PageHeader {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
      uncompressed_page_size: f_2.expect("auto-generated code should have checked for presence of required fields"),
      compressed_page_size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      crc: f_4,
      data_page_header: f_5,
      index_page_header: f_6,
      dictionary_page_header: f_7,
      data_page_header_v2: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PageHeader");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("uncompressed_page_size", TType::I32, 2))?;
    o_prot.write_i32(self.uncompressed_page_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("compressed_page_size", TType::I32, 3))?;
    o_prot.write_i32(self.compressed_page_size)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.crc {
      o_prot.write_field_begin(&TFieldIdentifier::new("crc", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.data_page_header {
      o_prot.write_field_begin(&TFieldIdentifier::new("data_page_header", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.index_page_header {
      o_prot.write_field_begin(&TFieldIdentifier::new("index_page_header", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.dictionary_page_header {
      o_prot.write_field_begin(&TFieldIdentifier::new("dictionary_page_header", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.data_page_header_v2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("data_page_header_v2", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// KeyValue
//

/// Wrapper struct to store key values
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct KeyValue {
  pub key: String,
  pub value: Option<String>,
}

impl KeyValue {
  pub fn new<F2>(key: String, value: F2) -> KeyValue where F2: Into<Option<String>> {
    KeyValue {
      key: key,
      value: value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<KeyValue> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("KeyValue.key", &f_1)?;
    let ret = KeyValue {
      key: f_1.expect("auto-generated code should have checked for presence of required fields"),
      value: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("KeyValue");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 1))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SortingColumn
//

/// Wrapper struct to specify sort order
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct SortingColumn {
  /// The column index (in this row group) *
  pub column_idx: i32,
  /// If true, indicates this column is sorted in descending order. *
  pub descending: bool,
  /// If true, nulls will come before non-null values, otherwise,
  /// nulls go at the end.
  pub nulls_first: bool,
}

impl SortingColumn {
  pub fn new(column_idx: i32, descending: bool, nulls_first: bool) -> SortingColumn {
    SortingColumn {
      column_idx: column_idx,
      descending: descending,
      nulls_first: nulls_first,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SortingColumn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SortingColumn.column_idx", &f_1)?;
    verify_required_field_exists("SortingColumn.descending", &f_2)?;
    verify_required_field_exists("SortingColumn.nulls_first", &f_3)?;
    let ret = SortingColumn {
      column_idx: f_1.expect("auto-generated code should have checked for presence of required fields"),
      descending: f_2.expect("auto-generated code should have checked for presence of required fields"),
      nulls_first: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SortingColumn");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_idx", TType::I32, 1))?;
    o_prot.write_i32(self.column_idx)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("descending", TType::Bool, 2))?;
    o_prot.write_bool(self.descending)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nulls_first", TType::Bool, 3))?;
    o_prot.write_bool(self.nulls_first)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PageEncodingStats
//

/// statistics of a given page type and encoding
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct PageEncodingStats {
  /// the page type (data/dic/...) *
  pub page_type: PageType,
  /// encoding of the page *
  pub encoding: Encoding,
  /// number of pages of this type with this encoding *
  pub count: i32,
}

impl PageEncodingStats {
  pub fn new(page_type: PageType, encoding: Encoding, count: i32) -> PageEncodingStats {
    PageEncodingStats {
      page_type: page_type,
      encoding: encoding,
      count: count,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<PageEncodingStats> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<PageType> = None;
    let mut f_2: Option<Encoding> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PageType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Encoding::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PageEncodingStats.page_type", &f_1)?;
    verify_required_field_exists("PageEncodingStats.encoding", &f_2)?;
    verify_required_field_exists("PageEncodingStats.count", &f_3)?;
    let ret = PageEncodingStats {
      page_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      encoding: f_2.expect("auto-generated code should have checked for presence of required fields"),
      count: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PageEncodingStats");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("page_type", TType::I32, 1))?;
    self.page_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encoding", TType::I32, 2))?;
    self.encoding.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("count", TType::I32, 3))?;
    o_prot.write_i32(self.count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ColumnMetaData
//

/// Description for column metadata
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct ColumnMetaData {
  /// Type of this column *
  pub type_: Type,
  /// Set of all encodings used for this column. The purpose is to validate
  /// whether we can decode those pages. *
  pub encodings: Vec<Encoding>,
  /// Path in schema *
  pub path_in_schema: Vec<String>,
  /// Compression codec *
  pub codec: CompressionCodec,
  /// Number of values in this column *
  pub num_values: i64,
  /// total byte size of all uncompressed pages in this column chunk (including the headers) *
  pub total_uncompressed_size: i64,
  /// total byte size of all compressed pages in this column chunk (including the headers) *
  pub total_compressed_size: i64,
  /// Optional key/value metadata *
  pub key_value_metadata: Option<Vec<KeyValue>>,
  /// Byte offset from beginning of file to first data page *
  pub data_page_offset: i64,
  /// Byte offset from beginning of file to root index page *
  pub index_page_offset: Option<i64>,
  /// Byte offset from the beginning of file to first (only) dictionary page *
  pub dictionary_page_offset: Option<i64>,
  /// optional statistics for this column chunk
  pub statistics: Option<Statistics>,
  /// Set of all encodings used for pages in this column chunk.
  /// This information can be used to determine if all data pages are
  /// dictionary encoded for example *
  pub encoding_stats: Option<Vec<PageEncodingStats>>,
}

impl ColumnMetaData {
  pub fn new<F8, F10, F11, F12, F13>(type_: Type, encodings: Vec<Encoding>, path_in_schema: Vec<String>, codec: CompressionCodec, num_values: i64, total_uncompressed_size: i64, total_compressed_size: i64, key_value_metadata: F8, data_page_offset: i64, index_page_offset: F10, dictionary_page_offset: F11, statistics: F12, encoding_stats: F13) -> ColumnMetaData where F8: Into<Option<Vec<KeyValue>>>, F10: Into<Option<i64>>, F11: Into<Option<i64>>, F12: Into<Option<Statistics>>, F13: Into<Option<Vec<PageEncodingStats>>> {
    ColumnMetaData {
      type_: type_,
      encodings: encodings,
      path_in_schema: path_in_schema,
      codec: codec,
      num_values: num_values,
      total_uncompressed_size: total_uncompressed_size,
      total_compressed_size: total_compressed_size,
      key_value_metadata: key_value_metadata.into(),
      data_page_offset: data_page_offset,
      index_page_offset: index_page_offset.into(),
      dictionary_page_offset: dictionary_page_offset.into(),
      statistics: statistics.into(),
      encoding_stats: encoding_stats.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ColumnMetaData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Type> = None;
    let mut f_2: Option<Vec<Encoding>> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<CompressionCodec> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<Vec<KeyValue>> = None;
    let mut f_9: Option<i64> = None;
    let mut f_10: Option<i64> = None;
    let mut f_11: Option<i64> = None;
    let mut f_12: Option<Statistics> = None;
    let mut f_13: Option<Vec<PageEncodingStats>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Type::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Encoding> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = Encoding::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_string()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = CompressionCodec::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KeyValue> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = KeyValue::read_from_in_protocol(i_prot)?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i64()?;
          f_11 = Some(val);
        },
        12 => {
          let val = Statistics::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        13 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<PageEncodingStats> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = PageEncodingStats::read_from_in_protocol(i_prot)?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_13 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ColumnMetaData.type_", &f_1)?;
    verify_required_field_exists("ColumnMetaData.encodings", &f_2)?;
    verify_required_field_exists("ColumnMetaData.path_in_schema", &f_3)?;
    verify_required_field_exists("ColumnMetaData.codec", &f_4)?;
    verify_required_field_exists("ColumnMetaData.num_values", &f_5)?;
    verify_required_field_exists("ColumnMetaData.total_uncompressed_size", &f_6)?;
    verify_required_field_exists("ColumnMetaData.total_compressed_size", &f_7)?;
    verify_required_field_exists("ColumnMetaData.data_page_offset", &f_9)?;
    let ret = ColumnMetaData {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
      encodings: f_2.expect("auto-generated code should have checked for presence of required fields"),
      path_in_schema: f_3.expect("auto-generated code should have checked for presence of required fields"),
      codec: f_4.expect("auto-generated code should have checked for presence of required fields"),
      num_values: f_5.expect("auto-generated code should have checked for presence of required fields"),
      total_uncompressed_size: f_6.expect("auto-generated code should have checked for presence of required fields"),
      total_compressed_size: f_7.expect("auto-generated code should have checked for presence of required fields"),
      key_value_metadata: f_8,
      data_page_offset: f_9.expect("auto-generated code should have checked for presence of required fields"),
      index_page_offset: f_10,
      dictionary_page_offset: f_11,
      statistics: f_12,
      encoding_stats: f_13,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ColumnMetaData");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encodings", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.encodings.len() as i32))?;
    for e in &self.encodings {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("path_in_schema", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.path_in_schema.len() as i32))?;
    for e in &self.path_in_schema {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("codec", TType::I32, 4))?;
    self.codec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("num_values", TType::I64, 5))?;
    o_prot.write_i64(self.num_values)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("total_uncompressed_size", TType::I64, 6))?;
    o_prot.write_i64(self.total_uncompressed_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("total_compressed_size", TType::I64, 7))?;
    o_prot.write_i64(self.total_compressed_size)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.key_value_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_value_metadata", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("data_page_offset", TType::I64, 9))?;
    o_prot.write_i64(self.data_page_offset)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.index_page_offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("index_page_offset", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.dictionary_page_offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("dictionary_page_offset", TType::I64, 11))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.statistics {
      o_prot.write_field_begin(&TFieldIdentifier::new("statistics", TType::Struct, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.encoding_stats {
      o_prot.write_field_begin(&TFieldIdentifier::new("encoding_stats", TType::List, 13))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ColumnChunk
//

#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct ColumnChunk {
  /// File where column data is stored.  If not set, assumed to be same file as
  /// metadata.  This path is relative to the current file.
  /// 
  pub file_path: Option<String>,
  /// Byte offset in file_path to the ColumnMetaData *
  pub file_offset: i64,
  /// Column metadata for this chunk. This is the same content as what is at
  /// file_path/file_offset.  Having it here has it replicated in the file
  /// metadata.
  /// 
  pub meta_data: Option<ColumnMetaData>,
}

impl ColumnChunk {
  pub fn new<F1, F3>(file_path: F1, file_offset: i64, meta_data: F3) -> ColumnChunk where F1: Into<Option<String>>, F3: Into<Option<ColumnMetaData>> {
    ColumnChunk {
      file_path: file_path.into(),
      file_offset: file_offset,
      meta_data: meta_data.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ColumnChunk> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<ColumnMetaData> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = ColumnMetaData::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ColumnChunk.file_offset", &f_2)?;
    let ret = ColumnChunk {
      file_path: f_1,
      file_offset: f_2.expect("auto-generated code should have checked for presence of required fields"),
      meta_data: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ColumnChunk");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.file_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_path", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("file_offset", TType::I64, 2))?;
    o_prot.write_i64(self.file_offset)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.meta_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("meta_data", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RowGroup
//

#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct RowGroup {
  /// Metadata for each column chunk in this row group.
  /// This list must have the same order as the SchemaElement list in FileMetaData.
  /// 
  pub columns: Vec<ColumnChunk>,
  /// Total byte size of all the uncompressed column data in this row group *
  pub total_byte_size: i64,
  /// Number of rows in this row group *
  pub num_rows: i64,
  /// If set, specifies a sort ordering of the rows in this RowGroup.
  /// The sorting columns can be a subset of all the columns.
  pub sorting_columns: Option<Vec<SortingColumn>>,
}

impl RowGroup {
  pub fn new<F4>(columns: Vec<ColumnChunk>, total_byte_size: i64, num_rows: i64, sorting_columns: F4) -> RowGroup where F4: Into<Option<Vec<SortingColumn>>> {
    RowGroup {
      columns: columns,
      total_byte_size: total_byte_size,
      num_rows: num_rows,
      sorting_columns: sorting_columns.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RowGroup> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ColumnChunk>> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<Vec<SortingColumn>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ColumnChunk> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = ColumnChunk::read_from_in_protocol(i_prot)?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SortingColumn> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = SortingColumn::read_from_in_protocol(i_prot)?;
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("RowGroup.columns", &f_1)?;
    verify_required_field_exists("RowGroup.total_byte_size", &f_2)?;
    verify_required_field_exists("RowGroup.num_rows", &f_3)?;
    let ret = RowGroup {
      columns: f_1.expect("auto-generated code should have checked for presence of required fields"),
      total_byte_size: f_2.expect("auto-generated code should have checked for presence of required fields"),
      num_rows: f_3.expect("auto-generated code should have checked for presence of required fields"),
      sorting_columns: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RowGroup");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.columns.len() as i32))?;
    for e in &self.columns {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("total_byte_size", TType::I64, 2))?;
    o_prot.write_i64(self.total_byte_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("num_rows", TType::I64, 3))?;
    o_prot.write_i64(self.num_rows)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.sorting_columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("sorting_columns", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// FileMetaData
//

/// Description for file metadata
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct FileMetaData {
  /// Version of this file *
  pub version: i32,
  /// Parquet schema for this file.  This schema contains metadata for all the columns.
  /// The schema is represented as a tree with a single root.  The nodes of the tree
  /// are flattened to a list by doing a depth-first traversal.
  /// The column metadata contains the path in the schema for that column which can be
  /// used to map columns to nodes in the schema.
  /// The first element is the root *
  pub schema: Vec<SchemaElement>,
  /// Number of rows in this file *
  pub num_rows: i64,
  /// Row groups in this file *
  pub row_groups: Vec<RowGroup>,
  /// Optional key/value metadata *
  pub key_value_metadata: Option<Vec<KeyValue>>,
  /// String for application that wrote this file.  This should be in the format
  /// <Application> version <App Version> (build <App Build Hash>).
  /// e.g. impala version 1.0 (build 6cf94d29b2b7115df4de2c06e2ab4326d721eb55)
  /// 
  pub created_by: Option<String>,
}

impl FileMetaData {
  pub fn new<F5, F6>(version: i32, schema: Vec<SchemaElement>, num_rows: i64, row_groups: Vec<RowGroup>, key_value_metadata: F5, created_by: F6) -> FileMetaData where F5: Into<Option<Vec<KeyValue>>>, F6: Into<Option<String>> {
    FileMetaData {
      version: version,
      schema: schema,
      num_rows: num_rows,
      row_groups: row_groups,
      key_value_metadata: key_value_metadata.into(),
      created_by: created_by.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<FileMetaData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Vec<SchemaElement>> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<Vec<RowGroup>> = None;
    let mut f_5: Option<Vec<KeyValue>> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SchemaElement> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = SchemaElement::read_from_in_protocol(i_prot)?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<RowGroup> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = RowGroup::read_from_in_protocol(i_prot)?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KeyValue> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = KeyValue::read_from_in_protocol(i_prot)?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("FileMetaData.version", &f_1)?;
    verify_required_field_exists("FileMetaData.schema", &f_2)?;
    verify_required_field_exists("FileMetaData.num_rows", &f_3)?;
    verify_required_field_exists("FileMetaData.row_groups", &f_4)?;
    let ret = FileMetaData {
      version: f_1.expect("auto-generated code should have checked for presence of required fields"),
      schema: f_2.expect("auto-generated code should have checked for presence of required fields"),
      num_rows: f_3.expect("auto-generated code should have checked for presence of required fields"),
      row_groups: f_4.expect("auto-generated code should have checked for presence of required fields"),
      key_value_metadata: f_5,
      created_by: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FileMetaData");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I32, 1))?;
    o_prot.write_i32(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schema", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.schema.len() as i32))?;
    for e in &self.schema {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("num_rows", TType::I64, 3))?;
    o_prot.write_i64(self.num_rows)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("row_groups", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.row_groups.len() as i32))?;
    for e in &self.row_groups {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.key_value_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_value_metadata", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.created_by {
      o_prot.write_field_begin(&TFieldIdentifier::new("created_by", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

